## CH4

### 1. 核心主题
本讲主要探讨如何在分布式系统中实时地（on-the-fly）记录系统的**全局状态**。这在分布式系统的调试、检查点恢复（checkpointing）和死锁检测中非常重要。

### 2. 主要难点（为什么这个问题很复杂）
PPT指出，在分布式系统中记录全局状态并非易事，主要面临以下挑战：
*   **缺乏全局共享内存**：各个节点无法直接看到其他节点的实时状态。
*   **缺乏全局统一时钟**：不同节点的时钟可能不同步，很难确定“同一时刻”。
*   **不可预测的消息延迟**：节点间通信存在延迟，且延迟时间不确定。

### 3. 本章学习目标与结构
这一章节的内容将分为以下几个部分展开：
*   **定义一致性全局状态 (Consistent Global States)**：首先明确什么是“一致的”状态，即如何定义一个在逻辑上合理的分布式系统“瞬间”。
*   **探讨计算一致性快照的问题**：讨论在实现快照过程中需要解决的关键问题和技术难点。
*   **介绍算法**：针对不同类型的网络环境，介绍几种用于实时获取分布式快照的具体算法（例如著名的 Chandy-Lamport 算法通常就在这一章讲解）。
![alt text](image-11.png)
典型案例，说明了一个一致性的系统快照需要能捕捉到节点的状态和当时正在信道中传输的信息。


### 系统模型的基础定义
*   **系统构成**：系统由一组 $n$ 个进程 $p_1, p_2, \dots, p_n$ 组成，这些进程之间通过信道（channels）相互连接。
*   **环境假设**：系统中不存在全局共享内存，也没有物理上的全局时钟；进程之间完全通过在通信信道中传递消息来进行交互。
*   **信道表示**：$C_{ij}$ 表示从进程 $p_i$ 到进程 $p_j$ 的单向信道，其状态记为 $SC_{ij}$。
*   **动作建模**：进程执行的动作被建模为三种类型的事件：**内部事件**（Internal events）、**消息发送事件**（the message send event）以及**消息接收事件**（the message receive event）。
*   **消息标识**：对于从进程 $p_i$ 发送到进程 $p_j$ 的消息 $m_{ij}$，使用 $send(m_{ij})$ 表示其发送事件，使用 $rec(m_{ij})$ 表示其接收事件。

### 进程状态与在途消息
*   **局部状态定义**：在任何时刻，进程 $p_i$ 的状态（记为 $LS_i$）是该进程截至该时刻所执行的所有事件序列共同作用的结果。
*   **事件归属判定（已发生）**：对于一个事件 $e$ 和一个进程状态 $LS_i$，当且仅当 $e$ 属于促使进程 $p_i$ 达到状态 $LS_i$ 的事件序列时，判定为 $e \in LS_i$。
*   **事件归属判定（未发生）**：对于一个事件 $e$ 和一个进程状态 $LS_i$，当且仅当 $e$ 不属于促使进程 $p_i$ 达到状态 $LS_i$ 的事件序列时，判定为 $e \notin LS_i$。
*   **信道消息集定义**：对于一条信道 $C_{ij}$，可以根据发送方进程 $p_i$ 和接收方进程 $p_j$ 的局部状态，定义如下的消息集合：
    *   **在途消息（Transit）**：$transit(LS_i, LS_j) = \{ m_{ij} \mid send(m_{ij}) \in LS_i \wedge rec(m_{ij}) \notin LS_j \}$。
    *   **补充说明**：这个公式是全篇的核心，它定义了哪些消息属于“正在路上”。即：发送方 $p_i$ 的记录里已经显示消息已发出（$send \in LS_i$），但接收方 $p_j$ 的记录里还没有收到这条消息（$rec \notin LS_j$）。在做分布式快照时，这些“在途”的消息必须被捕捉到，否则系统的全局状态就不完整。


### 通信模型 (Models of communication)
*   **三种模型回顾**：回顾一下，通信模型主要有三种：FIFO（先进先出）、非 FIFO 以及 Co（因果序通信）。
*   **FIFO 模型**：在 FIFO 模型中，每个信道都充当一个先进先出的消息队列，因此，信道会保持消息的发送顺序。
*   **非 FIFO 模型**：在非 FIFO 模型中，信道表现得像一个集合（Set），发送进程向其中添加消息，而接收进程则以随机顺序从中取出消息。
*   **因果序模型 (Co)**：一个支持消息因果传递（Causal delivery）的系统满足以下属性：“对于任意两条消息 $m_{ij}$ 和 $m_{kj}$，如果发送事件之间存在因果关系，即 $send(m_{ij}) \longrightarrow send(m_{kj})$，那么接收顺序也必须满足 $rec(m_{ij}) \longrightarrow rec(m_{kj})$。”（补充：这确保了如果消息 A 的发送触发了消息 B 的发送，那么任何节点收到 B 之前必然已经收到了 A）。

### 一致性全局状态 (Consistent global state)
*   **全局状态的组成**：分布式系统的全局状态是所有进程的局部状态（Local states）和所有信道状态（Channel states）的集合。
*   **数学定义**：在符号表示上，全局状态 $GS$ 定义为：$GS = \{ \bigcup_i LS_i, \bigcup_{i,j} SC_{ij} \}$。（补充：即所有进程 $p_i$ 的局部状态 $LS_i$ 与所有信道 $C_{ij}$ 的状态 $SC_{ij}$ 的并集）。
*   **一致性判别标准**：一个全局状态 $GS$ 当且仅当满足以下两个条件时，才被称为**一致性全局状态**：
    *   **条件 C1**：$send(m_{ij}) \in LS_i \implies m_{ij} \in SC_{ij} \oplus rec(m_{ij}) \in LS_j$。
        *   （注：$\oplus$ 是异或算子）。
        *   （补充解析：这意味着如果发送方 $p_i$ 记录了消息已发送，那么在全局状态中，这封信要么还在路上 $SC_{ij}$，要么已经被接收方收到 $LS_j$，二者必居其一。这保证了信息不会凭空消失，也不会被重复计算）。
    *   **条件 C2**：$send(m_{ij}) \notin LS_i \implies m_{ij} \notin SC_{ij} \wedge rec(m_{ij}) \notin LS_j$。
        *   （补充解析：这意味着如果发送方 $p_i$ 的状态显示还没发送这条消息，那么在全局状态中，信道里绝对不能有这条消息，接收方也绝对不可能已经收到了这条消息。这杜绝了“未发先收”的逻辑错误，即所谓的“幽灵消息”）。

### 基于“割”（Cuts）视角的解读
*   **割的定义**：在时空图（space-time diagram）中，**割（Cut）**是连接每个进程线上任意一点的一条线，它将整个时空图切分为**“过去”（PAST）**和**“未来”（FUTURE）**两个部分。
*   **一致性状态的对应关系**：一个一致性的全局状态，对应于这样一个割：即在该割的PAST部分接收到的信息也已经在PAST部分发送了。满足上述条件的割被称为**一致性割（consistent cut）**。
*   **实例分析**：例如，考虑图 4.1 中所示的计算过程时空图（图中包含四个进程 $p_1$ 到 $p_4$ 以及若干消息传递事件）。
*   **关于割 C1 的判定**：**割 C1 是不一致的**。其原因是消息 $m_1$ 正在从“未来”流向“过去”。
*   **关于割 C2 的判定**：**割 C2 是一致的**。在这种情况下，消息 $m_4$ 必须作为信道 $C_{21}$ 的状态被捕捉到。（补充：因为 $m_4$ 的发送发生在 C2 的左侧，而接收发生在 C2 的右侧，它属于“已发出但尚未接收”的在途消息。根据前面 PPT 的定义，它应计入信道状态，且这种‘从过去流向未来’的消息不破坏割的一致性）。
![alt text](image-12.png)


### 记录全局状态面临的问题
*   **需要解决的两个核心问题**：在记录全局状态时，必须妥善处理以下两个议题：
*   **议题 I1：如何区分哪些消息应当被记录在快照中，哪些不应当。**
    *   任何进程在记录其局部快照**之前**发送的消息，都必须被记录在全局快照中（这遵循了一致性条件 C1）。
    *   任何进程在记录其局部快照**之后**发送的消息，都绝不能被记录在全局快照中（这遵循了一致性条件 C2）。
*   **议题 I2：如何确定进程执行快照的时刻。**
    *   进程 $p_j$ 必须在处理任何由进程 $p_i$ 在记录快照**之后**发送的消息 $m_{ij}$ **之前**，先完成自己的快照记录。（补充：这保证了因果逻辑的正确性，防止“未来”的消息影响“过去”的快照）。

### 针对 FIFO 信道的快照算法：Chandy-Lamport 算法
*   **算法核心**：Chandy-Lamport 算法使用一种特殊的控制消息，称为**标记（marker）**。在 FIFO（先进先出）系统中，它的作用是充当信道中消息的“分隔符”。
*   **发送流程**：在一个站点记录完其局部快照后，它会在发送任何其他后续消息之前，向其所有的传出信道（outgoing channels）发送一个“标记”。
*   **标记的作用**：该“标记”将信道中的消息序列分成了两类：一类是应当被包含在快照中的消息，另一类则是那些不应被记录在快照中的消息。
*   **快照触发时机**：一个进程记录其局部快照的时刻，**不得晚于**它从其任何传入信道（incoming channels）收到“标记”的时刻。（补充：这意味着如果进程还没主动拍快照，一旦收到别人的标记，就必须立刻强制执行快照记录）。


#### Chandy-Lamport 算法的基本流程
*   **算法启动**：该算法可以由系统中的任何进程发起。发起进程通过执行**标记发送规则 (Marker Sending Rule)** 来启动算法，在此规则下，进程会记录其局部状态，并向其每一个传出信道发送一个“标记”（marker）。
*   **收到标记时的处理**：当一个进程收到“标记”时，它会执行**标记接收规则 (Marker Receiving Rule)**。如果该进程尚未记录自己的局部状态，它会将收到标记的那个信道的状态记录为“空”，并执行“标记发送规则”来记录其局部状态。
*   **算法终止条件**：在每一个进程都从其所有的传入信道收到了标记之后，算法即告终止。
*   **全局状态确定**：所有的局部快照随后会被分发给所有其他进程，从而使所有进程都能确定系统的全局状态。

#### Chandy-Lamport 算法的核心规则
*   **进程 $i$ 的标记发送规则 (Marker Sending Rule)**：
    1.  进程 $i$ 记录其当前状态。
    2.  对于每一个尚未发送过标记的传出信道 $C$，进程 $i$ 在沿信道 $C$ 发送任何进一步的消息之前，必须先沿该信道发送一个“标记”。（补充：这确保了“标记”充当了快照前消息与快照后消息的分隔符）。

*   **进程 $j$ 的标记接收规则 (Marker Receiving Rule)**：
    *   当进程 $j$ 沿信道 $C$ 收到一个“标记”时：
    *   **如果进程 $j$ 尚未记录其状态**：
        1.  将信道 $C$ 的状态记录为**空集**。（补充：因为收到标记意味着信道中在快照点之前的消息已经全部收完，没有在途消息）。
        2.  紧接着执行“标记发送规则”（即记录自身状态并向外广播标记）。
    *   **否则（即进程 $j$ 之前已经记录过自己的状态）**：
        1.  将信道 $C$ 的状态记录为一组消息的集合，这些消息是指：**在进程 $j$ 记录自身状态之后、且在进程 $j$ 沿信道 $C$ 收到该标记之前**，通过信道 $C$ 接收到的所有消息。（补充：这些就是算法定义中“正在路上”的在途消息）。


#### 算法的正确性与复杂性
*   **正确性说明**：
    *   由于信道具有 **FIFO（先进先出）属性**，可以推断出，在信道上位于“标记”（marker）之后发送的任何消息，都不会被记录在该信道的状态中。因此，**条件 C2 得到了满足**。（补充：这确保了快照中不会包含“未来”才发出的消息）。
    *   当进程 $p_j$ 接收到信道 $C_{ij}$ 上先于“标记”到达的消息 $m_{ij}$ 时，它按如下方式操作：如果进程 $p_j$ 尚未进行快照记录，则将 $m_{ij}$ 包含在其记录的快照中；否则，它将 $m_{ij}$ 记录在信道 $C_{ij}$ 的状态中。因此，**条件 C1 得到了满足**。（补充：这保证了所有在快照时刻已经发出但未被处理的消息都会被记录，不会凭空消失）。
*   **复杂度分析**：
    *   单次运行该算法的记录部分需要 **$O(e)$** 条消息和 **$O(d)$** 的时间复杂度，其中 $e$ 是网络中的边（信道）数量，$d$ 是网络的直径。

#### 所记录全局状态的性质
*   **状态的真实性问题**：记录下来的全局状态**可能并不对应**于计算过程中实际发生过的任何一个全局状态。
*   **发生原因**：这种情况之所以会发生，是因为进程可以在它发送的“标记”被其他站点接收并记录状态之前，异步地改变自身状态。（补充：由于各节点拍照有先后，记录下的可能是一个“拼凑”出来的瞬间）。
*   **等价性与实用价值**：
    *   但是，系统在某些**等价执行**（equivalent executions）中可能已经经历过这个被记录的全局状态。
    *   记录的全局状态在等价执行中是一个**有效状态**；并且，如果某种**稳定属性**（stable property，即一旦变为真就保持为真的属性，如死锁或系统终止）在快照算法开始前就在系统中成立，那么它在记录的全局快照中也必然成立。
    *   因此，记录的全局状态在**检测稳定属性**方面非常有用。

这两张 PPT 介绍了 **Spezialetti-Kearns 算法**，该算法是对 Chandy-Lamport 算法的改进，特别针对系统中存在**多个并发发起者**的情况进行了优化。以下是内容的逐句还原与解析：

#### Spezialetti-Kearns 算法的核心机制
*   **获取快照的两个阶段**：获取全局快照包含两个阶段：一是在每个进程上进行局部快照的记录，二是将生成的全局快照分发给所有的发起者。
*   **高效的快照记录流程**：
    *   在 Spezialetti-Kearns 算法中，标记（markers）携带了算法发起者的标识符。每个进程都维护一个名为 `master` 的变量，用于跟踪启动该算法的发起者。
    *   算法优化中使用的一个核心概念是系统中的**区域（region）**。一个“区域”包含了所有 `master` 字段存储了相同发起者标识符的进程。
    *   当进程从信道收到一个标记，且该标记中的发起者标识符与自身 `master` 变量中的值不同时，说明该标记的发送者处于不同的区域。
    *   此时，这个并发发起者的标识符会被记录在局部变量 `id-border-set`（边界 ID 集合）中。（这说明了这个process处在两个或多个master的边界，但是它的master取决于最早收到的标记）
*   **信道与进程状态的记录细节**：
    *   信道状态的记录方式与 Chandy-Lamport 算法完全相同（这也包括那些跨越区域边界的信道）。
    *   对于一个进程而言，当它从自己的所有信道都收到了标记后，其局部快照记录工作即告完成。
    *   在每个进程都完成了快照记录后，整个系统会被划分为若干个区域，区域的数量等同于算法并发发起的次数。
    *   进程中的变量 `id-border-set` 存储了所有邻近区域的标识符。


#### 高效分发已记录的快照
*   **已记录快照的高效分发**：
    *   在快照记录阶段，系统中会隐式地创建出一个**生成树森林（a forest of spanning trees）**。
    *   算法的每一个发起者都是其对应生成树的根节点，而其所在区域内的所有进程都属于这棵生成树。
*   **生成树中的父子关系**：如果进程 $p_i$ 从 $p_j$ 接收到了它的第一个标记（marker），那么在生成树中，进程 $p_j$ 就是进程 $p_i$ 的父节点。（补充：这定义了快照信息回传的路径，第一个传给你标记的节点就是你的“上线”）。
*   **中间进程的汇聚行为**：当生成树中的一个中间进程接收到了来自其所有子进程记录的状态，并且已经记录了其所有传入信道的状态时，它会将自身记录的状态以及其所有后代进程记录的状态一并转发给它的父节点。（补充：这是一种自底向上的数据聚合机制，确保信息能逐级向根节点汇总）。
*   **发起者的组装任务**：当发起者（即生成树的根节点）从其子进程那里接收到了所有后代进程的记录状态时，它会为自己所在区域内的所有进程以及与这些进程相关的信道组装出本区域的快照。
*   **区域间的快照交换**：发起者会分轮次地与相邻区域的发起者交换各自区域的快照。（补充：通过这种方式，原本被“瓜分”的各局部快照最终被拼凑成完整的全局状态）。
*   **复杂度分析**：
    *   **快照记录阶段**的消息复杂度为 **$O(e)$**，且该复杂度与算法并发发起的次数无关。（补充：这是该算法最大的优势，即无论有多少人同时发起快照，记录阶段的总消息数只与系统总信道数 $e$ 相关，避免了重复开销）。
    *   **组装和分发快照阶段**的消息复杂度为 **$O(rn^2)$**，其中 $r$ 是并发发起的次数，$n$ 是进程总数。


### 非 FIFO 信道下的快照挑战
*   **标记机制的失效**：在非 FIFO 系统中，由于消息可以乱序到达，**“标记”（marker）不能再被用来区分**哪些消息应当被记录在全局状态中，哪些不应当。（补充：在 FIFO 中，标记像隔板；但在非 FIFO 中，标记后的消息可能比标记先跑到，导致分类失效）。
*   **解决思路**：在非 FIFO 系统中，为了捕捉乱序消息，要么需要某种程度的**抑制（inhibition）**，要么需要将控制信息**搭便车（piggybacking）**在普通的计算消息上。

### Lai-Yang 算法（基于染色方案）
Lai-Yang 算法通过在计算消息上使用一套**“染色方案” (coloring scheme)**，在非 FIFO 系统中实现了类似“标记”的功能。其运作机制如下：
1.  **进程变色**：每个进程最初都是**白色 (white)** 的，在进行快照时会变为**红色 (red)**。当进程变红的那一刻，就相当于执行了“标记发送规则”。
2.  **消息染色**：由白色进程发送的每一条消息都被染成白色；由红色进程发送的每一条消息都被染成红色。
3.  **颜色的含义**：因此，一条**白色消息**代表该消息是在发送方记录局部快照**之前**发送的；而一条**红色消息**代表该消息是在发送方记录局部快照**之后**发送的。
4.  **强制快照时机**：每一个白色进程可以根据自己的方便选择记录快照的时机，但其记录时刻**不得晚于**它接收到红色消息的那一刻。（补充：这意味着如果你还是白色，却收到了红色的“未来消息”，你必须立刻变红并记录快照，以保证因果一致性）。

这张 PPT 承接前一页，继续详细解释了 **Lai-Yang 算法** 在非 FIFO 环境下如何记录消息历史并计算信道状态。以下是内容的逐句还原与解析：

#### Lai-Yang 算法的具体操作与信道状态计算

*   **记录历史**：每一个处于白色状态的进程，都会记录它在各个信道上发送或接收的所有**白色消息**的历史记录。
*   **发送数据**：当一个进程变红（即执行局部快照记录）时，它会将这些记录下来的历史信息，连同它的局部快照一起发送给负责收集全局快照的**发起进程（initiator process）**。
*   **计算在途消息（信道状态）**：发起进程通过评估 $transit(LS_i, LS_j)$ 来计算信道 $C_{ij}$ 的状态，计算方式如下：
    *   $SC_{ij} = $ 进程 $p_i$ 在信道 $C_{ij}$ 上发送的白色消息集合 **减去** 进程 $p_j$ 在该信道上接收到的白色消息集合。（通过这种方式就解决了non-FIFO信道可能产生的接收进程红色而信道中还有白色消息的问题）
    *   **形式化定义**：$SC_{ij} = \{ send(m_{ij}) \mid send(m_{ij}) \in LS_i \} - \{ rec(m_{ij}) \mid rec(m_{ij}) \in LS_j \}$。

**补充说明：**
由于在非 FIFO（非先进先出）系统中，消息的到达顺序是不可预测的，我们不能像 Chandy-Lamport 算法那样简单地靠“标记”来截断消息流。

Lai-Yang 算法的巧妙之处在于采用了**集合减法**的思想：
1.  **发送方的视野**：$p_i$ 记录了所有在快照时刻之前（变红前）发出的“白色信件”。
2.  **接收方的视野**：$p_j$ 记录了所有在快照时刻之前（变红前）收到的“白色信件”。
3.  **逻辑差集**：发起者把这两份名单拿来对比，如果有一封信在 $p_i$ 的发送名单里，但不在 $p_j$ 的接收名单里，那么这封信在逻辑快照那一刻，就一定**正在信道中传输（即在途消息）**。

通过这种“对账”的方式，即使信道里的消息跑得再乱，发起者也能准确地把那些“漏掉”的在途消息找回来，拼凑成一个完整的一致性全局状态。

Mattern 算法是一种基于向量时钟（Vector Clocks）的分布式快照算法。该算法假设系统中只有一个发起者（Initiator）进程，其具体工作流程如下：

### **Mattern 算法的基本步骤**

1.  **启动与广播：** 发起者进程将其本地时钟“滴答”增加，并选择一个未来的向量时间 $s$ 作为记录全局快照的时间点。随后，它广播这个时间 $s$，并冻结自身的所有活动，直到收到所有其他进程对该广播的确认（acknowledgements）。
2.  **确认机制：** 当其他进程收到该广播时，会记录下数值 $s$，并向发起者返回一个确认消息。
3.  **触发阶段：** 在收到所有进程的确认后，发起者将其向量时钟增加到 $s$，并向所有进程广播一条“哑消息”（dummy message）。
4.  **强制更新：** 每个接收者在收到这条哑消息后，如果其本地时钟尚未达到 $s$，则会被强制将其时钟增加到某个大于或等于 $s$ 的值。
5.  **记录本地快照：** 每个进程在本地时钟从小于 $s$ 的值增加到大于或等于 $s$ 的值那一刻（即刚好在增加之前），拍摄本地快照（Local Snapshot, $LS$）并将其发送给发起者。
6.  **确定信道状态：** 信道 $C_{ij}$ 的状态被定义为：所有沿该信道发送、且时间戳小于 $s$ 的消息，并且这些消息是在接收进程 $p_j$ 记录完其本地快照 $LS_j$ 之后才被收到的。


### **非 FIFO 信道下的终止检测**

在非 FIFO（先入先出）信道中，由于消息可能乱序到达，需要一种终止检测方案来确保没有“白色消息”（即在快照时间点 $s$ 之前发送的消息）仍在传输途中。

**具体方法如下：**

*   **维护计数器：** 每个进程 $i$ 维护一个计数器 $cntr_i$。该计数器用于记录在拍摄快照之前，该进程发送的白色消息数量与收到的白色消息数量之间的差值。
*   **报告与转发：** 进程将此计数器的值随其本地快照一起报告给发起者进程。在此之后，该进程若收到任何白色消息，都会将其转发给发起者。
*   **终止条件：** 当发起者收到的转发白色消息的总数量等于所有进程报告的计数器之和（即 $\sum_i cntr_i$）时，快照收集过程正式终止。

**补充说明：**
所谓“白色消息”是指那些在发送者逻辑时钟达到 $s$ 之前发出的消息。在非 FIFO 环境下，这些消息可能在快照拍摄后很久才到达，因此需要通过计数器确保所有发出的白色消息都已被接收并记录在信道状态中，从而保证全局快照的一致性。

针对你提供的 Mattern 算法的“第二种方法”（Second method），这同样是解决**在非 FIFO 环境下如何知道信道快照收集何时结束**的问题。

以下是该 PPT 内容的中文还原及补充说明：

### **Mattern 算法：第二种方法 (Second Method)**

这是另一种用于检测快照终止的方案，与第一种依赖“全局计数器之和”不同，这种方法更侧重于**点对点**的感知：

*   **红色消息捎带计数：** 每个进程在拍摄本地快照后（变为红色）发送的每条**红色消息**中，都会捎带一个数值。这个数值表示：在拍摄快照之前，该进程在**该特定信道**上总共发送了多少条**白色消息**。
*   **接收端计数：** 每个进程都会为自己所有的入站信道维护一个计数器，专门统计在每个信道上已经收到了多少条白色消息。
*   **局部终止检测：** 当一个进程在某个入站信道上收到的白色消息总数，**等于**该信道上收到的红色消息所捎带的那个数值时，它就可以确定该特定信道的快照记录已经完成（即所有该收的白色消息都已收到）。


### **进一步的补充与对比（帮助理解）**

为了让你更清楚为什么有这个方法，以及它和之前的区别，可以参考以下几点：

#### **1. 它如何解决非 FIFO 带来的困扰？**
在非 FIFO 信道中，发送方先发的白色消息 $W$ 可能会比后发的红色消息 $R$ 晚到。
*   **如果没有这个方法：** 接收方收到红色消息 $R$ 后，它不知道后面是否还有“迷路”的白色消息 $W$。
*   **有了这个方法：** 红色消息 $R$ 变成了一个“通知单”。比如 $R$ 告诉接收方：“我在记录快照前一共给你发了 10 条白色消息。” 即使 $R$ 跑得快先到了，接收方数了数手里只有 9 条白消息，它就知道：“哦，还有 1 条在路上，我得继续等，直到那条到齐了，这个信道的快照才算收完。”

#### **2. 与“第一种方法”的区别**
*   **第一种方法（全局汇总）：** 每个进程把自己的差值报告给**发起者**，由发起者统一做减法，看最后是不是等于 0。这是一种**集中式**的检测。
*   **第二种方法（局部验证）：** 每个接收进程自己就能根据收到的红色消息判断某个信道是否已经“收全了”。这是一种更具**分布式**色彩的检测方式。

#### mattern相对于laiyang的改进之处
laiyang虽然通过染色机制让它可以应用在non-fifo信道中，但是依然存在不完备性。即没有内部机制去解决终止检测的问题。具体地说，虽然laiyang对进程i,j的状态做减法可以得知信道中存在在途的信息，但是它不知道什么时候结束，即不知道在途信息什么时候送达（因为laiyang没有强制转发机制）。

还有个就是目标值是动态地上报给发起者进程的，即使知道了进程A和B的之间发送-接收的差值也无法确定准确的差值是多少的，因为可能还存在进程C没有上报，而C和B之间可能也发了信息

mattern的第一种方法，它会强制所有进程上报$cntr_i$，这样发起者就知道整个系统还有多少白色消息没到达，当cntr清零，发起者就知道快照结束了；第二种方法呢，则是把检测信道结束的状态下放给了接收者，当接收者确认白色信息的数目对了，这个信道的快照就结束了。


这两张 PPT 讨论的是在**支持因果交付（Causal Delivery）**的分布式系统中，如何进行全局快照（Global Snapshot）记录。

在这种特定的系统环境下，快照算法可以利用底层的因果序属性进行简化。PPT 提到了两个著名的算法：**Acharya-Badrinath 算法**和 **Alagar-Venkatesan 算法**。

以下是对 PPT 内容的完整还原、详细解释以及额外的知识补充。

---


### 因果交付系统中的快照 (Snapshots in a causal delivery system)

*   **因果消息交付属性 (CO)**：提供了内置的消息同步机制，用于控制消息和计算消息。
*   **两种全局快照记录算法**：即 **Acharya-Badrinath** 算法和 **Alagar-Venkatesan** 算法。它们都假设底层系统支持因果消息交付。
*   在这两个算法中，**进程状态（Process State）的记录方式是相同的**，步骤如下：
    1.  一个**发起者进程（Initiator process）**向包括它自己在内的所有进程广播一个令牌（token）。
    2.  记进程 $p_i$ 接收到的令牌副本为 $token_i$。
    3.  进程 $p_i$ 在接收到 $token_i$ 时，记录其**本地快照 $LS_i$**，并将记录好的快照发送给发起者。
    4.  当发起者收到每个进程记录的快照时，算法**终止**。

#### 正确性证明 (Correctness)

对于任意两个进程 $p_i$ 和 $p_j$，满足以下属性（一致性状态的核心条件）：
$$send(m_{ij}) \notin LS_i \Rightarrow rec(m_{ij}) \notin LS_j$$
*（解释：如果消息 $m_{ij}$ 的发送动作没有被记录在 $p_i$ 的快照里，那么该消息的接收动作也绝不会出现在 $p_j$ 的快照里。）*

**证明逻辑如下：**
这是由于底层系统的**因果排序属性**（Causal Ordering Property）决定的：
*   假设有一条消息 $m_{ij}$，满足 $rec(token_i) \longrightarrow send(m_{ij})$（即 $p_i$ 在记录快照后才发送消息）。
*   由于令牌是广播的，那么存在因果链：$send(token_j) \longrightarrow send(m_{ij})$。
*   底层因果排序属性确保：$rec(token_j)$（即进程 $p_j$ 记录 $LS_j$ 的时刻）必然发生在 $rec(m_{ij})$ **之前**。
*   因此，发送动作未记录在 $LS_i$ 中的消息 $m_{ij}$，其接收动作也不会被记录在 $LS_j$ 中。

*   **注意**：这两个算法在**通道状态**的记录方法上有所不同，将在后续讨论。


> 什么是因果排序属性 (CO)？
> 这是分布式系统中的一个强约束。如果一个进程发送了 $m_1$ 接着发送了 $m_2$，或者一个进程收到 $m_1$ 后触发了 $m_2$ 的发送，那么系统必须保证所有目的地进程都在收到 $m_2$ 之前收到 $m_1$。

这两张 PPT 详细介绍了在支持因果交付（Causal Delivery）的系统中，**Acharya-Badrinath 算法**是如何记录**通道状态（Channel State）**的。

以下是对 PPT 内容的中文解释、原文还原以及相关补充知识。

---

### Acharya-Badrinath 算法中的通道状态记录

*   每个进程 $p_i$ 维护两个数组：$SENT_i[1, \dots, N]$ 和 $RECD_i[1, \dots, N]$。
    *   $SENT_i[j]$：由进程 $p_i$ 发送给进程 $p_j$ 的消息总数。
    *   $RECD_i[j]$：进程 $p_i$ 从进程 $p_j$ 接收到的消息总数。
*   **通道状态记录方式如下**：
    当进程 $p_i$ 在接收到 $token_i$ 并记录其本地快照 $LS_i$ 时，它会将 $RECD_i$ 和 $SENT_i$ 数组包含在本地状态中，然后再将快照发送给发起者（Initiator）。


当算法终止时，发起者按如下方式确定各通道的状态：

*   **从发起者到每个进程的通道状态**：为空（Empty）。
*   **从进程 $p_i$ 到进程 $p_j$ 的通道状态**：是指这样一组消息，其序列号由以下集合给定：
    $$\{RECD_j[i] + 1, \dots, SENT_i[j]\}$$
    *（解释：即 $p_i$ 发送了但 $p_j$ 尚未收到的那部分消息序列。序号从j已接收的消息下一个开始记录到i发送的最后一个消息的序号）*

**复杂度 (Complexity)**：
*   该算法需要 **$2n$ 条消息**和 **2 个时间单位**来进行快照的记录和汇聚（假设消息传递需要 1 个时间单位）。
    *   *1 个时间单位用于广播 token，$n$ 条消息。*
    *   *1 个时间单位用于各进程发回快照，$n$ 条消息。*
*   如果需要通道状态中**消息的具体内容**，则算法额外需要 $2n$ 条消息和 2 个时间单位。

---

#### 核心原理解析

1. 为什么只需要“计数”就能确定通道状态？
在普通的分布式系统（非因果序）中，为了知道通道里有哪些消息，我们需要非常复杂的机制（如 Chandy-Lamport 的 Marker）。
但在 **因果交付 (CO)** 系统中，消息是严格按序到达的。
*   如果进程 $p_i$ 说：“我给 $p_j$ 发了 10 条消息（$SENT_i[j]=10$）”。
*   进程 $p_j$ 说：“我只收到了 $p_i$ 的 7 条消息（$RECD_j[i]=7$）”。
*   由于因果序保证了消息不会乱序或跳跃，那么第 8、9、10 这三条消息**必然**还在通道中。

2. 为什么从发起者出发的通道为空？
发起者是第一个记录快照并发出 `token` 的。根据因果排序属性，发起者在拍完快照后发送的任何消息，其发送动作都在 `token` 之后。因此，这些消息到达接收者时，接收者必然已经收到了 `token` 并拍好了快照。
所以，这些消息既不在发送者的快照里，也不在接收者的快照里，它们不属于“通道状态”（即不属于“已发送但未接收”的消息）。

3. 关于“额外 $2n$ 条消息”的补充
PPT 提到，基础算法只通过 $SENT$ 和 $RECD$ 数组确定了**哪些编号**的消息在通道中（例如“第 8, 9, 10 条消息在途”）。
但发起者此时并没有这些消息的**实际内容**（Payload）。如果全局快照要求保存消息内容，发起者必须再向 $p_i$ 请求这些具体的编号消息，这就会产生额外的通信开销。


### Alagar-Venkatesan 算法中的通道状态记录

在因果交付系统中，消息被分为两类：
*   **旧消息 (old)**：如果消息的发送在因果关系上**先于**令牌（token）的发送，则称该消息为“旧”消息。
*   **新消息 (new)**：否则，该消息被称为“新”消息。

**Alagar-Venkatesan 算法记录通道状态的步骤如下：**
1.  **第一阶段**：当一个进程收到 `token` 时，它执行以下操作：
    *   记录其本地快照（Snapshot）。
    *   将所有通道的状态初始化为**空**。
    *   向发起者（Initiator）返回一条 `Done` 消息。
    *   **从此往后**，进程仅在收到“旧消息”时，才将其计入通道状态中。
2.  **第二阶段**：当发起者收到来自所有进程的 `Done` 消息后，它广播一条 `Terminate`（终止）消息。
3.  **第三阶段**：进程在收到 `Terminate` 消息后，停止快照算法（不再记录通道状态）。


#### 1. “旧消息”与“新消息”的判定原理
在支持 **CO（因果排序）** 的系统中，每个消息通常带有向量时钟（Vector Clock）。当 $p_i$ 收到 `token` 时，它会记录下当前的向量时钟 $V_{snapshot}$。
*   如果收到的消息 $m$ 携带的时钟 $V_m < V_{snapshot}$，则它是“旧消息”。
*   在 Alagar-Venkatesan 算法中，通道状态就是：**在拍完快照后收到的所有“旧消息”**。

#### 2. 为什么需要 `Terminate` 消息？
这是 Alagar-Venkatesan 算法与 Acharya-Badrinath 算法的最大区别：
*   **Acharya-Badrinath** 是“算”出来的。发起者收集所有 $SENT$ 和 $RECD$ 计数，然后在后台减一下就知道哪些在途。
*   **Alagar-Venkatesan** 是“等”出来的。每个进程在拍完快照后，进入一个“监听模式”，专门收集那些还没到的“旧消息”。
*   **问题是：要等到什么时候为止？** 进程不知道“旧消息”是否已经全部拿到了。因此需要发起者作为一个中心节点，确认大家都拍完快照了（收到所有 `Done`），再发一个 `Terminate` 通知大家可以停止监听了。

#### 3. 算法复杂度对比 ($2n$ vs $3n$)
*   **Acharya-Badrinath ($2n$ 消息)**：
    1. 发起者广播 Token ($n$)。
    2. 大家发回快照和计数 ($n$)。
    *总计 $2n$。*
*   **Alagar-Venkatesan ($3n$ 消息)**：
    1. 发起者广播 Token ($n$)。
    2. 大家发回 `Done` ($n$)。
    3. 发起者广播 `Terminate` ($n$)。
    *总计 $3n$。*

#### 4. 补充：为什么叫“分布式”计算通道状态？
在 **Acharya-Badrinath** 中，通道状态是在发起者那里算出来的（发起者拥有全局计数信息）。
在 **Alagar-Venkatesan** 中，每个进程在“监听模式”下自己就把发给自己的在途消息收集全了，然后每个进程各保存一部分通道状态，这被称为“分布式计算”。

#### 总结
Alagar-Venkatesan 算法利用了因果系统的属性，将“在途消息”转化为“快照后到达的旧消息”。虽然它比 Acharya-Badrinath 多了一轮消息传递（$3n$ vs $2n$），但它的逻辑更符合在线处理的直觉——实时捕获那些迟到的“旧消息”。

### 各快照算法总结对比 (Algorithms Comparison)

| 算法名称 | 特点与复杂度 |
| :--- | :--- |
| **Chandy-Lamport** | 基准算法。要求 FIFO 通道。复杂度为 $O(e)$ 条消息，$O(d)$ 时间。 |
| **Spezialetti-Kearns** | 支持并发发起者，高效的快照汇聚与分发。假设双向通道。$O(e)$ 记录，$O(rn^2)$ 汇聚分发。 |
| **Lai-Yang** | 适用于**非 FIFO** 通道。标记（Markers）搭在计算消息上。需要消息历史记录来计算通道状态。 |
| **Li et al.** | 需要较小的消息历史记录，因为通道状态是增量计算的。 |
| **Mattern** | 不需要消息历史记录。需要**终止检测（Termination detection）**来计算通道状态。 |
| **Acharya-Badrinath** | 要求因果交付支持。**集中式**计算通道状态。无需知道消息内容。需 $2n$ 消息，2 时间单位。 |
| **Alagar-Venkatesan** | 要求因果交付支持。**分布式**计算通道状态。需 $3n$ 消息，3 时间单位，消息体积小。 |

*注：$n$ = 进程数，$e$ = 通道数，$d$ = 网络直径，$r$ = 并发发起者数量。*


### 一致性全局快照的充要条件 

*   许多应用要求在执行过程中或事后（Post mortem）定期记录并分析本地进程状态。
*   进程在执行过程中保存的中间状态被称为该进程的一个**本地检查点（Local Checkpoint）**。
*   一个**一致性快照（Consistent Snapshot）**由一组并发发生、或具有同时发生潜力的本地状态组成。
*   进程**异步地**设置检查点。进程 $p_p$ 的第 $i$ 个（$i \ge 0$）检查点被赋予序列号 $i$，记作 **$C_{p,i}$**。
*   我们假设：每个进程在执行开始前有一个**初始检查点**，在执行结束后有一个**虚拟检查点**。
*   进程 $p_p$ 的**第 $i$ 个检查点区间（Checkpoint interval）**定义为：在其第 $(i-1)$ 个和第 $i$ 个检查点之间执行的所有计算（包括第 $(i-1)$ 个检查点，但不包括第 $i$ 个）。


*   **核心观点**：即使两个本地检查点之间没有因果路径（即互不达），它们也可能**不属于**同一个一致性全局快照。
*   **示例分析**（参考 Figure 4.2，虽然图中未画出，但给出了结论）：
    *   尽管检查点 $C_{1,1}$ 和 $C_{3,2}$ 都没有在对方之前发生（即它们在因果序上是并行的），但它们无法与进程 $p_2$ 上的任何检查点组合形成一个一致性的全局快照。
![alt text](image-13.png)
---


*   为了描述一致性快照的充分必要条件，Netzer 和 Xu 对 Lamport 的“因果先于（happen before）”关系进行了推广，定义了 **Z-路径（zigzag path）**。
*   两个检查点之间的 Z-路径类似于一条因果路径，但它允许路径中的**某条消息在上一条消息被接收之前就发出**。
*   在图 4.2 中，虽然从 $C_{1,1}$ 到 $C_{3,2}$ 不存在因果路径，但确实存在一条从 $C_{1,1}$ 到 $C_{3,2}$ 的 **Z-路径**。
*   这条 Z-路径意味着：在这次执行过程中，**不存在**任何包含 $C_{1,1}$ 和 $C_{3,2}$ 的一致性快照。

### Z-路径与一致性全局快照

**定义 (Definition)：**
从检查点 $C_{x,i}$ 到检查点 $C_{y,j}$ 存在一条 **Z-路径**，当且仅当存在消息序列 $m_1, m_2, \dots, m_n (n \ge 1)$ 满足以下条件：
1.  消息 $m_1$ 是由进程 $p_x$ 在 $C_{x,i}$ **之后**发送的。
2.  对于序列中的每一对相邻消息，如果 $m_k (1 \le k \le n)$ 被进程 $p_z$ 接收，那么 $m_{k+1}$ 是由 $p_z$ 在**同一个或更晚的**检查点区间内发送的（即便 $m_{k+1}$ 可能在 $m_k$ 被接收之前(或之后)就已经发出了）。
3.  消息 $m_n$ 被进程 $p_y$ 在 $C_{y,j}$ **之前**接收。

**示例 (Example)：**
在图 4.2 中，由于消息 $m_3$ 和 $m_4$ 的存在，从 $C_{1,1}$ 到 $C_{3,2}$ 存在一条 Z-路径。


> ### 核心原理解析：为什么 Z-路径如此重要？
> 
>#### 1. 它是对因果序的“增强版”
>*   **因果路径 (Causal Path)** 要求：$C \to send(m_1) \to recv(m_1) \to send>(m_2) \to recv(m_2) \dots$（时间上必须是一直向后的）。
>*   **Z-路径 (Zigzag Path)** 允许：$C \to send(m_1) \to [ \text{某个区间} ] >\leftarrow send(m_2) \to recv(m_2) \dots$
>    *   在定义第 2 条中，关键在于“**同一个检查点区间**”。
>    *   这意味着在同一个区间内，发送动作可以比接收动作更早发生。这种“逆流而上”的逻辑>流依然会传递一种“**不兼容性**”。
>
>#### 2. 直观解释 Z-路径的破坏力
>我们可以把检查点看作“存档点”。
>*   如果 $C_{x,i} \xrightarrow{Z-path} C_{y,j}$，说明这两个存档点之间存在某种逻辑>冲突。
>*   如果你试图同时读取这两个存档，你可能会发现：**根据 $p_y$ 的存档，它已经收到了某>个东西；但根据 $p_x$ 的存档，那个东西根本还没发出来。**
>*   即便中间隔了千山万水（多个进程），只要这根 Z 字型的链条连上了，一致性就被打破了。
>
>#### 3. 重新审视图 4.2 的例子
>*   $m_3$ 在 $C_{1,1}$ **之后**发出（满足条件 1）。
>*   $p_2$ 接收了 $m_3$，而 $m_4$ 是在 $p_2$ 的**同一个检查点区间**（即 $C_{2,1}$ >到 $C_{2,2}$ 之间）发出的（满足条件 2）。
>*   $m_4$ 在 $C_{3,2}$ **之前**被 $p_3$ 接收（满足条件 3）。
>*   **结果**：链条打通，$C_{1,1}$ 和 $C_{3,2}$ 彻底绝缘，无法共存。


### Z-环 (Zigzag cycle)

**定义 (Definition)：**
一个检查点 $C$ 参与了一个 **Z-环**，当且仅当存在一条从 $C$ 到其自身的 **Z-路径**。

*   **图 4.3 示例**：检查点 $C_{2,1}$ 处于由消息 $m_1$ 和 $m_2$ 形成的 Z-环上。
*   **Z-环路径追踪**：
    1.  从 $C_{2,1}$ 出发：进程 $p_2$ 在拍完 $C_{2,1}$ 后发送了消息 $m_2$。
    2.  到达 $p_1$：$p_1$ 接收了 $m_2$，接收点位于检查点区间 $[C_{1,0}, C_{1,1}]$ 内。
    3.  折返：在同一个检查点区间 $[C_{1,0}, C_{1,1}]$ 内，$p_1$ 之前发送过消息 $m_1$。根据 Z-路径定义，即使 $m_1$ 发送早于 $m_2$ 接收，由于它们在同一个区间，逻辑上可连通。
    4.  回到起点：消息 $m_1$ 被 $p_2$ 接收，且接收点位于 $C_{2,1}$ **之前**。
    5.  **结论**：形成了一条 $C_{2,1} \to \dots \to C_{2,1}$ 前的闭环。
![alt text](image-14.png)
---

>#### 为什么 Z-环非常致命？因为无论怎么画线，一定有消息是只有接收而无发送的，一致性失效了。
>在分布式快照理论中，Netzer 和 Xu 证明了一个重要结论：
>**如果一个检查点 $C$ 参与了一个 Z-环，那么它就是“无用的（Unuseful）”。**
>这意味着，无论其他进程如何配合，都找不到任何一个一致性全局快照能包含这个检查点。在系>统崩溃恢复时，这个存档点永远无法被使用，必须回滚到更早的状态。
### Z-路径与因果路径的区别 (Difference between a zigzag path and a causal path)

*   **因果路径**：从检查点 A 到检查点 B 存在因果路径，当且仅当存在一条消息链，链条起始于 A 之后，结束于 B 之前，且链中**每条消息的发送都必须晚于前一条消息的接收**（严格遵守时间流向）。
*   **Z-路径**：也由类似的消息链组成，但是，只要发送和接收动作处于**同一个检查点区间**内，链中的消息**可以早于前一条消息的接收而被发送**。
*   **包含关系**：因此，因果路径永远是 Z-路径，但 Z-路径不一定是因果路径。
*   **成环特性**：另一个区别是，**Z-路径可以形成环（Cycle）**，而因果路径永远不会形成环（因为因果律在物理时间上是单向向前的）。
*   

这两张 PPT 总结了 **Z-路径理论** 的最终结论，并引入了一套形式化的符号系统，用于在复杂的分布式计算中寻找和构建一致性全局快照。

以下是对 PPT 内容的中文解释、详细还原以及相关背景知识的补充。

---

### 一致性全局快照

**核心结论：**
Netzer 和 Xu 证明了：如果一组检查点集合 $S$ 中的**任意两个**检查点之间都不存在 **Z-路径**（或 **Z-环**），那么就一定可以形成一个包含该集合 $S$ 的一致性快照；反之亦然。

*   **因果路径 vs Z-路径**：
    *   检查点之间**不存在因果路径**只是形成一致性快照的**必要条件**（即：如果有因果路径，一定不一致；但没有因果路径，也不一定一致）。
    *   检查点之间**不存在 Z-路径**则是形成一致性快照的**充分必要条件**
*   **集合的扩展性**：一组检查点 $S$ 可以被“补完”（扩展）成一个完整的一致性全局快照，当且仅当 $S$ 内部的检查点之间没有互相指向的 Z-路径。
*   **检查点的有效性**：一个本地检查点能够出现在某个一致性快照中，当且仅当它自身没有卷入 **Z-环（Z-cycle）** 中。如果一个检查点在 Z-环上，它就是“废档”，永远无法用于恢复。

---

### 在分布式计算中寻找一致性全局快照

*   **研究目标**：讨论如何将各进程独立的本地检查点与其他进程的检查点结合，形成一致的全局快照。
*   **参考文献**：Manivannan、Netzer 和 Singhal 对“如何从给定的检查点集合 $S$ 构建出所有可能的一致性快照”进行了深入分析。
*   **符号定义 ($\rightsquigarrow$)**：
    为了方便表述，引入关系符号 $\rightsquigarrow$ 来表示 **Z-路径** 关系。设 $A, B$ 为单个检查点，$R, S$ 为检查点集合：
    1.  **$A \rightsquigarrow B$**：表示从检查点 $A$ 到 $B$ 存在一条 Z-路径。
    2.  **$A \rightsquigarrow S$**：表示从检查点 $A$ 到集合 $S$ 中的**某个**成员存在一条 Z-路径。
    3.  **$S \rightsquigarrow A$**：表示从集合 $S$ 中的**某个**成员到检查点 $A$ 存在一条 Z-路径。
    4.  **$R \rightsquigarrow S$**：表示从集合 $R$ 中的**某个**成员到集合 $S$ 中的**某个**成员存在一条 Z-路径。

为了使描述更加严谨，这里使用了数学符号表示。$S \not\rightsquigarrow S$ 定义为：在集合 $S$ 中，不存在从其任何成员到任何其他成员（包括自身）的 **Z-路径**（这也就排除了 **Z-环**）。这个定义隐含了一个前提：$S$ 中的检查点都来自于不同的进程。

在此符号体系下，Netzer 和 Xu 的研究成果可以总结为以下定理：

*   **定理 4.1 (Theorem 4.1)**：一个检查点集合 $S$ 能够被扩展（补充）成一个完整的一致性全局快照，**当且仅当** $S \not\rightsquigarrow S$。
*   **推论 4.1 (Corollary 4.1)**：单个检查点 $C$ 能够成为某个一致性全局快照的一部分，**当且仅当**它没有卷入 **Z-环** 之中。
*   **推论 4.2 (Corollary 4.2)**：一个检查点集合 $S$ **本身就是一个**一致性全局快照，**当且仅当** $S \not\rightsquigarrow S$ 且 $|S| = N$（其中 $N$ 是系统中进程的总数）。


---

### 寻找一致性全局快照的候选成员

当我们已经拥有一个满足 $S \not\rightsquigarrow S$ 条件的检查点集合 $S$ 时（这意味着 $S$ 是有潜力的），下一步就是讨论：其他进程中的哪些检查点可以被拿来与 $S$ 组合，从而构建出一个更大的、且依然保持一致性的全局快照。

**首要观察结论 (First Observation)：**
1.  **排除项**：任何与 $S$ 中的检查点存在 Z-路径（无论是从 $S$ 指向它，还是它指向 $S$）的检查点都**不能**被使用。
2.  **入选条件**：只有那些与 $S$ 中所有检查点都**没有**双向 Z-路径的检查点，才是构建一致性快照的合格候选者。

---

#### Z-锥（Z-cone）与 C-锥（C-cone）的定义及关系

为了量化上述候选者的范围，PPT 引入了两个“锥”的概念：

*   **Z-锥 (Z-cone of $S$)**：指所有与 $S$ 中检查点**没有** Z-路径关系的检查点集合。这些是真正的、符合一致性充要条件的候选人。
*   **C-锥 (C-cone of $S$)**：指所有与 $S$ 中检查点**没有因果路径（Causal path）**关系的检查点集合。
*   **两者之间的关系**：
    *   由于因果路径本身就是一种特殊的 Z-路径，因此，如果两个点之间没有 Z-路径，那它们之间也一定没有因果路径。
    *   由此推导出：对于任意集合 $S$，**$S$ 的 Z-锥始终是 $S$ 的 C-锥的一个子集**（即：Z-cone $\subseteq$ C-cone）。
![alt text](image-15.png)



---


在确定候选检查点时，仅仅处于 Z-锥中是不够的，还需要排除掉那些“天生有缺陷”的检查点。

*   **再观察 (Second Observation)**：虽然构建一致性快照的候选检查点必须位于 $S$ 的 **Z-锥** 中，但并非 Z-锥内的所有检查点都能与 $S$ 组合形成一致性快照。
*   **核心理由**：如果 Z-锥中的某个检查点本身卷入了 **Z-环（Z-cycle）**，那么它就永远无法成为任何一致性快照的一部分（因为它无法满足自己到自己的一致性要求）。

---

#### 有用检查点集合（$S_{useful}$）的定义


**定义 (Definition)：**
假设 $S$ 是一个满足 $S \not\rightsquigarrow S$（即内部一致）的检查点集合。对于每个进程 $p_q$，**相对于 $S$ 的有用检查点集合 $S_{useful}^q$** 定义为：
$$S_{useful}^q = \{ C_{q,i} \mid (S \not\rightsquigarrow C_{q,i}) \wedge (C_{q,i} \not\rightsquigarrow S) \wedge (C_{q,i} \not\rightsquigarrow C_{q,i}) \}$$

**定义解读：**
一个检查点 $C_{q,i}$ 要想对 $S$ 来说是“有用的”，必须同时满足三个条件：
1.  **$S \not\rightsquigarrow C_{q,i}$**：不存在从 $S$ 到该点的 Z-路径（防止在该点看来，$S$ 变成了“未来”）。
2.  **$C_{q,i} \not\rightsquigarrow S$**：不存在从该点到 $S$ 的 Z-路径（防止在 $S$ 看来，该点变成了“未来”）。
3.  **$C_{q,i} \not\rightsquigarrow C_{q,i}$**：该点本身不能在 Z-环上（确保该点自身是有效的）。

此外，我们将所有进程的有用检查点取并集，定义为**全局有用集合**：
$$S_{useful} = \bigcup_q S_{useful}^q$$

---

### 寻找一致性快照的关键引理

这个引理为我们“扩充”快照提供了理论保证。

**引理 4.1 (Lemma 4.1)：**
“设 $S$ 是一个满足 $S \not\rightsquigarrow S$ 的检查点集合。设 $C_{q,i}$ 是进程 $p_q$ 上不属于 $S$ 的任意一个检查点。那么，集合 $S \cup \{C_{q,i}\}$ 可以被扩展为一个一致性全局快照，**当且仅当** $C_{q,i} \in S_{useful}$。”

**引理意义说明：**
引理 4.1 指出，如果我们已知一个一致的初始集合 $S$，那么我们可以确信：从 $S_{useful}$ 中挑选出的**任何单个**检查点，都可以安全地与 $S$ 结合，并最终拼凑成一个完整的、一致的全局快照。

---

### 第三个观察 (Third observation)

在之前的讨论中，我们定义了 $S_{useful}$（有用检查点集合）。接下来的观察揭示了构建完整快照时的最后一个关键约束。

*   **第三个观察 (Third observation)**：
    *   虽然 $S_{useful}$ 中的任何检查点与集合 $S$ 之间都没有 Z-路径（即它们与 $S$ 兼容），但 **$S_{useful}$ 的成员之间可能存在 Z-路径**。
    *   因此，当我们从 $S_{useful}$ 中挑选一个子集 $T$ 来补全快照时，必须加上最后一个约束：**$T$ 内部的检查点之间不能有 Z-路径**。此外，基于定理 4.1，既然 $S \not\rightsquigarrow S$，那么至少存在一个这样的 $T$。

*   **定理 4.2 (Theorem 4.2)**：
    设 $S$ 为一个满足 $S \not\rightsquigarrow S$ 的检查点集合，设 $T$ 为任何与 $S$ 不相交（$S \cap T = \emptyset$）的检查点集合。那么，$S \cup T$ 是一个一致性全局快照，**当且仅当**满足以下三个条件：
    1.  **$T \subseteq S_{useful}$**（$T$ 中的每个点都必须对 $S$ 有用，且自身不含 Z-环）。
    2.  **$T \not\rightsquigarrow T$**（$T$ 内部各点之间互不冲突，没有 Z-路径）。
    3.  **$|S \cup T| = N$**（合并后的集合涵盖了系统中所有的 $N$ 个进程）。



---

### Manivannan-Netzer-Singhal (MNS) 枚举一致性快照算法

这一部分给出了由 Manivannan、Netzer 和 Singhal 提出的算法伪代码，其目标是计算出**所有**包含给定集合 $S$ 的一致性快照。

**算法逻辑还原与步骤说明：**

1.  **`ComputeAllCgs(S)` (主函数)**：
    *   初始化结果集 $G$ 为空。
    *   首先检查 $S$ 本身是否内部一致（$S \not\rightsquigarrow S$）。
    *   如果一致，找到 $S$ 中尚未代表的所有进程集合 `AllProcs`（即那些在 $S$ 中没有检查点的进程）。
    *   调用递归辅助函数 `ComputeAllCgsFrom(S, AllProcs)` 开始搜索。
    *   最后返回所有找到的一致性快照集合 $G$。

2.  **`ComputeAllCgsFrom(T, ProcSet)` (递归搜索函数)**：
    *   **基准情况**：如果待处理进程集 `ProcSet` 为空，说明当前集合 $T$ 已经覆盖了所有进程，是一个完整的一致性快照，将其加入结果集 $G$。
    *   **递归步骤**：
        *   从 `ProcSet` 中任选一个进程 $p_q$。
        *   遍历该进程 $p_q$ 所有的“有用检查点” $C$（即属于 $T^q_{useful}$ 的点）。注意，这里的 $T^q_{useful}$ 是相对于当前已选集合 $T$ 来计算的。
        *   将该检查点 $C$ 加入集合 $T$，并从进程集中移除 $p_q$，然后进行下一层的递归调用。

---

这两张 PPT 讨论了 **Manivannan-Netzer-Singhal (MNS) 算法**的正确性，并引入了一个重要的工具——**回退依赖图 (Rollback-dependency Graph, R-graph)**，用于在离线状态下检测分布式计算中的 Z-路径。

以下是对 PPT 内容的详细还原、中文解释及额外知识补充。

---

### Manivannan-Netzer-Singhal (MNS) 算法

该算法的核心思想是将搜索范围严格限制在集合 $S$ 的 **Z-锥 (Z-cone)** 内，并排除掉其中包含 **Z-环 (Z-cycle)** 的检查点。

*   **算法逻辑**：算法仅选择那些与 $S$ 既没有 Z-路径指向、也没有从 $S$ 指出的检查点，同时在这些候选点中检查是否存在自指向的 Z-路径（即 Z-环）。
*   **定理 4.3 (Theorem 4.3)**：
    设 $S$ 为一个检查点集合，而 $G$ 是由函数 `ComputeAllCgs(S)` 返回的结果集。
    如果 $S \not\rightsquigarrow S$（即 $S$ 内部是一致的），那么 $T \in G$ 当且仅当 $T$ 是一个包含 $S$ 的一致性快照。
    **结论**：这意味着结果集 $G$ **准确且无遗漏地**包含了所有涵盖集合 $S$ 的一致性全局快照。

---

### 在分布式计算中寻找 Z-路径

这部分讨论如何判定已经终止或停止运行的分布式计算中，任意两个检查点之间是否存在 Z-路径。为了解决这个问题，引入了**回退依赖图 (R-graph)**。

*   **背景**：确定 Z-路径的存在是分析快照一致性的前提。在计算停止后（事后分析），我们可以构建一个全局依赖图来简化这种判定。
*   **回退依赖图 (R-graph) 的定义**：
    分布式计算的回退依赖图是一个有向图 $G = (V, E)$，其中：
    *   **顶点 $V$**：是该分布式计算中所有的本地检查点（Checkpoints）。
    *   **边 $(C_{p,i}, C_{q,j})$**：从检查点 $C_{p,i}$ 指向检查点 $C_{q,j}$ 的边属于集合 $E$，当且仅当满足以下任一条件：
        1.  **本地依赖**：$p = q$ 且 $j = i + 1$。
            *（解释：同一个进程中，后一个检查点依赖于前一个检查点，反映了时间的线性流动。）*
        2.  **消息依赖**：$p \neq q$，且有一条消息 $m$ 是从进程 $p_p$ 的**第 $i$ 个检查点区间**发送的，并在进程 $p_q$ 的**第 $j$ 个检查点区间**被接收（其中 $i, j > 0$）。
            *（解释：如果消息在 $C_{p,i}$ 之后发出，在 $C_{q,j}$ 之前被接收，则建立一条从发送方检查点到接收方检查点的边。）*

---



### 回退依赖图（R-graph）示例


*   **图 4.6 与图 4.5 的关系**：PPT 指出图 4.6（即 R-graph）是根据图 4.5 所示的分布式计算过程构建出来的。
*   **易失性检查点（Volatile Checkpoints）**：在图 4.6 中，出现了 $C_{1,3}$、$C_{2,3}$ 和 $C_{3,3}$。
    *   这些被称为**易失性检查点**，它们代表了每个进程在终止（Terminating）前所达到的**最后一个状态**。
    *   由于它们通常存在于内存中而非持久化存储，所以被称为“易失性”的。
*   **路径表示符号 ($\rightsquigarrow^{rd}$)**：
    *   使用 $C \rightsquigarrow^{rd} D$ 表示在 R-graph 中存在一条从检查点 $C$ 到检查点 $D$ 的**有向路径**。
    *   需要注意：这个符号仅仅表示路径的“存在性”，并不特指某一条具体的路径。

这张 PPT 是关于分布式系统快照理论的一个核心总结，它确立了逻辑上的 **Z-路径（Zigzag Path）** 与图论中的 **回退依赖图（R-graph）** 路径之间的等价关系。

简单来说，这页 PPT 告诉我们：**如何通过回退依赖图（R-graph）中的“可达性”来自动检测复杂的“Z-路径”和“Z-环”。**
![alt text](image-16.png)
![alt text](image-17.png)
---


下面的定理确立了 **R-graph 中的路径** 与 **检查点之间的 Z-路径** 之间的对应关系。

**定理 (Theorem)：**
设 $G = (V, E)$ 为分布式计算的回退依赖图（R-graph）。那么，对于任意两个检查点 $C_{p,i}$ 和 $C_{q,j}$，存在从 $C_{p,i}$ 到 $C_{q,j}$ 的 **Z-路径**（记作 $C_{p,i} \rightsquigarrow C_{q,j}$）当且仅当满足以下条件之一：
1.  **$p = q$ 且 $i < j$**；（即：在同一个进程中，后面的检查点天然与前面的检查点存在逻辑顺序）。
2.  **在图 $G$ 中，从 $C_{p,i+1}$ 到 $C_{q,j}$ 存在一条路径**（记作 $C_{p,i+1} \rightsquigarrow^{rd} C_{q,j}$）。在此情况下，$p$ 和 $q$ 也可以是同一个进程。

**示例 (Examples)：**
*   在图 4.5 中，存在一条从 $C_{1,1}$ 到 $C_{3,1}$ 的 Z-路径。这是因为在对应的回退依赖图（图 4.6）中，存在路径 **$C_{1,2} \rightsquigarrow^{rd} C_{3,1}$**。
*   同样地，检查点 **$C_{2,1}$ 位于一个 Z-环（Z-cycle）上**。这是因为在对应的图 4.6 中，存在路径 **$C_{2,2} \rightsquigarrow^{rd} C_{2,1}$**。（注：根据定理，如果从 $C_{2,1+1}$ 能回到 $C_{2,1}$，即意味着存在从 $C_{2,1}$ 到自身的 Z-路径）。



>#### 1. 为什么定理中是 $C_{p,i+1}$ 而不是 $C_{p,i}$？
>这是理解这个定理最关键的细节。
>*   根据 **Z-路径的定义**，路径中的第一条消息 $m_1$ 必须是在检查点 $C_{p,i}$ **>后**发送的。
>*   根据 **R-graph 边的定义**，如果在检查点 $C_{p,i}$ 之后发送了一条消息，那么在>退依赖图中，这条消息对应的边是从 **$C_{p,i+1}$** 出发的（因为 R-graph 的规则是将>间 $i+1$ 内的发送事件归结为指向其结束边界的依赖）。
>*   **结论**：因此，要检测一个“从 $C_{p,i}$ 之后开始”的 Z-路径，我们在图中必须从>的下一个检查点 **$C_{p,i+1}$** 开始寻找路径。
>
>#### 2. 定理如何判定 Z-环？
>*   **Z-环**的定义是：存在一条从检查点 $C$ 回到它自身的 Z-路径。
>*   根据定理条件 2，如果我们要看 $C_{2,1}$ 是否在 Z-环上，我们就去图中看能不能从>**$C_{2,2}$** 走到 **$C_{2,1}$**。
>*   如果能走到（如图 4.6 所示），就说明 $C_{2,1}$ 参与了一个逻辑冲突，它是一个“>用”的检查点，永远不能出现在任何一致性快照中。
>
>#### 3. $\rightsquigarrow$ 与 $\rightsquigarrow^{rd}$ 的符号区别
>*   **$\rightsquigarrow$（Z-路径）**：是 Netzer 和 Xu 定义的**逻辑概念**，涉及“>字形”的消息收发。
>*   **$\rightsquigarrow^{rd}$（R-graph 路径）**：是**图论概念**，表示有向图中节>之间的连通性。
>*   这页 PPT 的伟大之处在于将一个复杂的逻辑问题（找 Z-路径）转化为了一个简单的计算>算法问题（图的可达性搜索，如使用广度优先搜索 BFS）。















