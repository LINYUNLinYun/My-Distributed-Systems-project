## CH4

### 1. 核心主题
本讲主要探讨如何在分布式系统中实时地（on-the-fly）记录系统的**全局状态**。这在分布式系统的调试、检查点恢复（checkpointing）和死锁检测中非常重要。

### 2. 主要难点（为什么这个问题很复杂）
PPT指出，在分布式系统中记录全局状态并非易事，主要面临以下挑战：
*   **缺乏全局共享内存**：各个节点无法直接看到其他节点的实时状态。
*   **缺乏全局统一时钟**：不同节点的时钟可能不同步，很难确定“同一时刻”。
*   **不可预测的消息延迟**：节点间通信存在延迟，且延迟时间不确定。

### 3. 本章学习目标与结构
这一章节的内容将分为以下几个部分展开：
*   **定义一致性全局状态 (Consistent Global States)**：首先明确什么是“一致的”状态，即如何定义一个在逻辑上合理的分布式系统“瞬间”。
*   **探讨计算一致性快照的问题**：讨论在实现快照过程中需要解决的关键问题和技术难点。
*   **介绍算法**：针对不同类型的网络环境，介绍几种用于实时获取分布式快照的具体算法（例如著名的 Chandy-Lamport 算法通常就在这一章讲解）。
![alt text](image-11.png)
典型案例，说明了一个一致性的系统快照需要能捕捉到节点的状态和当时正在信道中传输的信息。


### 系统模型的基础定义
*   **系统构成**：系统由一组 $n$ 个进程 $p_1, p_2, \dots, p_n$ 组成，这些进程之间通过信道（channels）相互连接。
*   **环境假设**：系统中不存在全局共享内存，也没有物理上的全局时钟；进程之间完全通过在通信信道中传递消息来进行交互。
*   **信道表示**：$C_{ij}$ 表示从进程 $p_i$ 到进程 $p_j$ 的单向信道，其状态记为 $SC_{ij}$。
*   **动作建模**：进程执行的动作被建模为三种类型的事件：**内部事件**（Internal events）、**消息发送事件**（the message send event）以及**消息接收事件**（the message receive event）。
*   **消息标识**：对于从进程 $p_i$ 发送到进程 $p_j$ 的消息 $m_{ij}$，使用 $send(m_{ij})$ 表示其发送事件，使用 $rec(m_{ij})$ 表示其接收事件。

### 进程状态与在途消息
*   **局部状态定义**：在任何时刻，进程 $p_i$ 的状态（记为 $LS_i$）是该进程截至该时刻所执行的所有事件序列共同作用的结果。
*   **事件归属判定（已发生）**：对于一个事件 $e$ 和一个进程状态 $LS_i$，当且仅当 $e$ 属于促使进程 $p_i$ 达到状态 $LS_i$ 的事件序列时，判定为 $e \in LS_i$。
*   **事件归属判定（未发生）**：对于一个事件 $e$ 和一个进程状态 $LS_i$，当且仅当 $e$ 不属于促使进程 $p_i$ 达到状态 $LS_i$ 的事件序列时，判定为 $e \notin LS_i$。
*   **信道消息集定义**：对于一条信道 $C_{ij}$，可以根据发送方进程 $p_i$ 和接收方进程 $p_j$ 的局部状态，定义如下的消息集合：
    *   **在途消息（Transit）**：$transit(LS_i, LS_j) = \{ m_{ij} \mid send(m_{ij}) \in LS_i \wedge rec(m_{ij}) \notin LS_j \}$。
    *   **补充说明**：这个公式是全篇的核心，它定义了哪些消息属于“正在路上”。即：发送方 $p_i$ 的记录里已经显示消息已发出（$send \in LS_i$），但接收方 $p_j$ 的记录里还没有收到这条消息（$rec \notin LS_j$）。在做分布式快照时，这些“在途”的消息必须被捕捉到，否则系统的全局状态就不完整。


### 通信模型 (Models of communication)
*   **三种模型回顾**：回顾一下，通信模型主要有三种：FIFO（先进先出）、非 FIFO 以及 Co（因果序通信）。
*   **FIFO 模型**：在 FIFO 模型中，每个信道都充当一个先进先出的消息队列，因此，信道会保持消息的发送顺序。
*   **非 FIFO 模型**：在非 FIFO 模型中，信道表现得像一个集合（Set），发送进程向其中添加消息，而接收进程则以随机顺序从中取出消息。
*   **因果序模型 (Co)**：一个支持消息因果传递（Causal delivery）的系统满足以下属性：“对于任意两条消息 $m_{ij}$ 和 $m_{kj}$，如果发送事件之间存在因果关系，即 $send(m_{ij}) \longrightarrow send(m_{kj})$，那么接收顺序也必须满足 $rec(m_{ij}) \longrightarrow rec(m_{kj})$。”（补充：这确保了如果消息 A 的发送触发了消息 B 的发送，那么任何节点收到 B 之前必然已经收到了 A）。

### 一致性全局状态 (Consistent global state)
*   **全局状态的组成**：分布式系统的全局状态是所有进程的局部状态（Local states）和所有信道状态（Channel states）的集合。
*   **数学定义**：在符号表示上，全局状态 $GS$ 定义为：$GS = \{ \bigcup_i LS_i, \bigcup_{i,j} SC_{ij} \}$。（补充：即所有进程 $p_i$ 的局部状态 $LS_i$ 与所有信道 $C_{ij}$ 的状态 $SC_{ij}$ 的并集）。
*   **一致性判别标准**：一个全局状态 $GS$ 当且仅当满足以下两个条件时，才被称为**一致性全局状态**：
    *   **条件 C1**：$send(m_{ij}) \in LS_i \implies m_{ij} \in SC_{ij} \oplus rec(m_{ij}) \in LS_j$。
        *   （注：$\oplus$ 是异或算子）。
        *   （补充解析：这意味着如果发送方 $p_i$ 记录了消息已发送，那么在全局状态中，这封信要么还在路上 $SC_{ij}$，要么已经被接收方收到 $LS_j$，二者必居其一。这保证了信息不会凭空消失，也不会被重复计算）。
    *   **条件 C2**：$send(m_{ij}) \notin LS_i \implies m_{ij} \notin SC_{ij} \wedge rec(m_{ij}) \notin LS_j$。
        *   （补充解析：这意味着如果发送方 $p_i$ 的状态显示还没发送这条消息，那么在全局状态中，信道里绝对不能有这条消息，接收方也绝对不可能已经收到了这条消息。这杜绝了“未发先收”的逻辑错误，即所谓的“幽灵消息”）。

### 基于“割”（Cuts）视角的解读
*   **割的定义**：在时空图（space-time diagram）中，**割（Cut）**是连接每个进程线上任意一点的一条线，它将整个时空图切分为**“过去”（PAST）**和**“未来”（FUTURE）**两个部分。
*   **一致性状态的对应关系**：一个一致性的全局状态，对应于这样一个割：即在该割的PAST部分接收到的信息也已经在PAST部分发送了。满足上述条件的割被称为**一致性割（consistent cut）**。
*   **实例分析**：例如，考虑图 4.1 中所示的计算过程时空图（图中包含四个进程 $p_1$ 到 $p_4$ 以及若干消息传递事件）。
*   **关于割 C1 的判定**：**割 C1 是不一致的**。其原因是消息 $m_1$ 正在从“未来”流向“过去”。
*   **关于割 C2 的判定**：**割 C2 是一致的**。在这种情况下，消息 $m_4$ 必须作为信道 $C_{21}$ 的状态被捕捉到。（补充：因为 $m_4$ 的发送发生在 C2 的左侧，而接收发生在 C2 的右侧，它属于“已发出但尚未接收”的在途消息。根据前面 PPT 的定义，它应计入信道状态，且这种‘从过去流向未来’的消息不破坏割的一致性）。
![alt text](image-12.png)


### 记录全局状态面临的问题
*   **需要解决的两个核心问题**：在记录全局状态时，必须妥善处理以下两个议题：
*   **议题 I1：如何区分哪些消息应当被记录在快照中，哪些不应当。**
    *   任何进程在记录其局部快照**之前**发送的消息，都必须被记录在全局快照中（这遵循了一致性条件 C1）。
    *   任何进程在记录其局部快照**之后**发送的消息，都绝不能被记录在全局快照中（这遵循了一致性条件 C2）。
*   **议题 I2：如何确定进程执行快照的时刻。**
    *   进程 $p_j$ 必须在处理任何由进程 $p_i$ 在记录快照**之后**发送的消息 $m_{ij}$ **之前**，先完成自己的快照记录。（补充：这保证了因果逻辑的正确性，防止“未来”的消息影响“过去”的快照）。

### 针对 FIFO 信道的快照算法：Chandy-Lamport 算法
*   **算法核心**：Chandy-Lamport 算法使用一种特殊的控制消息，称为**标记（marker）**。在 FIFO（先进先出）系统中，它的作用是充当信道中消息的“分隔符”。
*   **发送流程**：在一个站点记录完其局部快照后，它会在发送任何其他后续消息之前，向其所有的传出信道（outgoing channels）发送一个“标记”。
*   **标记的作用**：该“标记”将信道中的消息序列分成了两类：一类是应当被包含在快照中的消息，另一类则是那些不应被记录在快照中的消息。
*   **快照触发时机**：一个进程记录其局部快照的时刻，**不得晚于**它从其任何传入信道（incoming channels）收到“标记”的时刻。（补充：这意味着如果进程还没主动拍快照，一旦收到别人的标记，就必须立刻强制执行快照记录）。


#### Chandy-Lamport 算法的基本流程
*   **算法启动**：该算法可以由系统中的任何进程发起。发起进程通过执行**标记发送规则 (Marker Sending Rule)** 来启动算法，在此规则下，进程会记录其局部状态，并向其每一个传出信道发送一个“标记”（marker）。
*   **收到标记时的处理**：当一个进程收到“标记”时，它会执行**标记接收规则 (Marker Receiving Rule)**。如果该进程尚未记录自己的局部状态，它会将收到标记的那个信道的状态记录为“空”，并执行“标记发送规则”来记录其局部状态。
*   **算法终止条件**：在每一个进程都从其所有的传入信道收到了标记之后，算法即告终止。
*   **全局状态确定**：所有的局部快照随后会被分发给所有其他进程，从而使所有进程都能确定系统的全局状态。

#### Chandy-Lamport 算法的核心规则
*   **进程 $i$ 的标记发送规则 (Marker Sending Rule)**：
    1.  进程 $i$ 记录其当前状态。
    2.  对于每一个尚未发送过标记的传出信道 $C$，进程 $i$ 在沿信道 $C$ 发送任何进一步的消息之前，必须先沿该信道发送一个“标记”。（补充：这确保了“标记”充当了快照前消息与快照后消息的分隔符）。

*   **进程 $j$ 的标记接收规则 (Marker Receiving Rule)**：
    *   当进程 $j$ 沿信道 $C$ 收到一个“标记”时：
    *   **如果进程 $j$ 尚未记录其状态**：
        1.  将信道 $C$ 的状态记录为**空集**。（补充：因为收到标记意味着信道中在快照点之前的消息已经全部收完，没有在途消息）。
        2.  紧接着执行“标记发送规则”（即记录自身状态并向外广播标记）。
    *   **否则（即进程 $j$ 之前已经记录过自己的状态）**：
        1.  将信道 $C$ 的状态记录为一组消息的集合，这些消息是指：**在进程 $j$ 记录自身状态之后、且在进程 $j$ 沿信道 $C$ 收到该标记之前**，通过信道 $C$ 接收到的所有消息。（补充：这些就是算法定义中“正在路上”的在途消息）。


#### 算法的正确性与复杂性
*   **正确性说明**：
    *   由于信道具有 **FIFO（先进先出）属性**，可以推断出，在信道上位于“标记”（marker）之后发送的任何消息，都不会被记录在该信道的状态中。因此，**条件 C2 得到了满足**。（补充：这确保了快照中不会包含“未来”才发出的消息）。
    *   当进程 $p_j$ 接收到信道 $C_{ij}$ 上先于“标记”到达的消息 $m_{ij}$ 时，它按如下方式操作：如果进程 $p_j$ 尚未进行快照记录，则将 $m_{ij}$ 包含在其记录的快照中；否则，它将 $m_{ij}$ 记录在信道 $C_{ij}$ 的状态中。因此，**条件 C1 得到了满足**。（补充：这保证了所有在快照时刻已经发出但未被处理的消息都会被记录，不会凭空消失）。
*   **复杂度分析**：
    *   单次运行该算法的记录部分需要 **$O(e)$** 条消息和 **$O(d)$** 的时间复杂度，其中 $e$ 是网络中的边（信道）数量，$d$ 是网络的直径。

#### 所记录全局状态的性质
*   **状态的真实性问题**：记录下来的全局状态**可能并不对应**于计算过程中实际发生过的任何一个全局状态。
*   **发生原因**：这种情况之所以会发生，是因为进程可以在它发送的“标记”被其他站点接收并记录状态之前，异步地改变自身状态。（补充：由于各节点拍照有先后，记录下的可能是一个“拼凑”出来的瞬间）。
*   **等价性与实用价值**：
    *   但是，系统在某些**等价执行**（equivalent executions）中可能已经经历过这个被记录的全局状态。
    *   记录的全局状态在等价执行中是一个**有效状态**；并且，如果某种**稳定属性**（stable property，即一旦变为真就保持为真的属性，如死锁或系统终止）在快照算法开始前就在系统中成立，那么它在记录的全局快照中也必然成立。
    *   因此，记录的全局状态在**检测稳定属性**方面非常有用。

这两张 PPT 介绍了 **Spezialetti-Kearns 算法**，该算法是对 Chandy-Lamport 算法的改进，特别针对系统中存在**多个并发发起者**的情况进行了优化。以下是内容的逐句还原与解析：

#### Spezialetti-Kearns 算法的核心机制
*   **获取快照的两个阶段**：获取全局快照包含两个阶段：一是在每个进程上进行局部快照的记录，二是将生成的全局快照分发给所有的发起者。
*   **高效的快照记录流程**：
    *   在 Spezialetti-Kearns 算法中，标记（markers）携带了算法发起者的标识符。每个进程都维护一个名为 `master` 的变量，用于跟踪启动该算法的发起者。
    *   算法优化中使用的一个核心概念是系统中的**区域（region）**。一个“区域”包含了所有 `master` 字段存储了相同发起者标识符的进程。
    *   当进程从信道收到一个标记，且该标记中的发起者标识符与自身 `master` 变量中的值不同时，说明该标记的发送者处于不同的区域。
    *   此时，这个并发发起者的标识符会被记录在局部变量 `id-border-set`（边界 ID 集合）中。（这说明了这个process处在两个或多个master的边界，但是它的master取决于最早收到的标记）
*   **信道与进程状态的记录细节**：
    *   信道状态的记录方式与 Chandy-Lamport 算法完全相同（这也包括那些跨越区域边界的信道）。
    *   对于一个进程而言，当它从自己的所有信道都收到了标记后，其局部快照记录工作即告完成。
    *   在每个进程都完成了快照记录后，整个系统会被划分为若干个区域，区域的数量等同于算法并发发起的次数。
    *   进程中的变量 `id-border-set` 存储了所有邻近区域的标识符。


#### 高效分发已记录的快照
*   **已记录快照的高效分发**：
    *   在快照记录阶段，系统中会隐式地创建出一个**生成树森林（a forest of spanning trees）**。
    *   算法的每一个发起者都是其对应生成树的根节点，而其所在区域内的所有进程都属于这棵生成树。
*   **生成树中的父子关系**：如果进程 $p_i$ 从 $p_j$ 接收到了它的第一个标记（marker），那么在生成树中，进程 $p_j$ 就是进程 $p_i$ 的父节点。（补充：这定义了快照信息回传的路径，第一个传给你标记的节点就是你的“上线”）。
*   **中间进程的汇聚行为**：当生成树中的一个中间进程接收到了来自其所有子进程记录的状态，并且已经记录了其所有传入信道的状态时，它会将自身记录的状态以及其所有后代进程记录的状态一并转发给它的父节点。（补充：这是一种自底向上的数据聚合机制，确保信息能逐级向根节点汇总）。
*   **发起者的组装任务**：当发起者（即生成树的根节点）从其子进程那里接收到了所有后代进程的记录状态时，它会为自己所在区域内的所有进程以及与这些进程相关的信道组装出本区域的快照。
*   **区域间的快照交换**：发起者会分轮次地与相邻区域的发起者交换各自区域的快照。（补充：通过这种方式，原本被“瓜分”的各局部快照最终被拼凑成完整的全局状态）。
*   **复杂度分析**：
    *   **快照记录阶段**的消息复杂度为 **$O(e)$**，且该复杂度与算法并发发起的次数无关。（补充：这是该算法最大的优势，即无论有多少人同时发起快照，记录阶段的总消息数只与系统总信道数 $e$ 相关，避免了重复开销）。
    *   **组装和分发快照阶段**的消息复杂度为 **$O(rn^2)$**，其中 $r$ 是并发发起的次数，$n$ 是进程总数。


### 非 FIFO 信道下的快照挑战
*   **标记机制的失效**：在非 FIFO 系统中，由于消息可以乱序到达，**“标记”（marker）不能再被用来区分**哪些消息应当被记录在全局状态中，哪些不应当。（补充：在 FIFO 中，标记像隔板；但在非 FIFO 中，标记后的消息可能比标记先跑到，导致分类失效）。
*   **解决思路**：在非 FIFO 系统中，为了捕捉乱序消息，要么需要某种程度的**抑制（inhibition）**，要么需要将控制信息**搭便车（piggybacking）**在普通的计算消息上。

### Lai-Yang 算法（基于染色方案）
Lai-Yang 算法通过在计算消息上使用一套**“染色方案” (coloring scheme)**，在非 FIFO 系统中实现了类似“标记”的功能。其运作机制如下：
1.  **进程变色**：每个进程最初都是**白色 (white)** 的，在进行快照时会变为**红色 (red)**。当进程变红的那一刻，就相当于执行了“标记发送规则”。
2.  **消息染色**：由白色进程发送的每一条消息都被染成白色；由红色进程发送的每一条消息都被染成红色。
3.  **颜色的含义**：因此，一条**白色消息**代表该消息是在发送方记录局部快照**之前**发送的；而一条**红色消息**代表该消息是在发送方记录局部快照**之后**发送的。
4.  **强制快照时机**：每一个白色进程可以根据自己的方便选择记录快照的时机，但其记录时刻**不得晚于**它接收到红色消息的那一刻。（补充：这意味着如果你还是白色，却收到了红色的“未来消息”，你必须立刻变红并记录快照，以保证因果一致性）。

这张 PPT 承接前一页，继续详细解释了 **Lai-Yang 算法** 在非 FIFO 环境下如何记录消息历史并计算信道状态。以下是内容的逐句还原与解析：

#### Lai-Yang 算法的具体操作与信道状态计算

*   **记录历史**：每一个处于白色状态的进程，都会记录它在各个信道上发送或接收的所有**白色消息**的历史记录。
*   **发送数据**：当一个进程变红（即执行局部快照记录）时，它会将这些记录下来的历史信息，连同它的局部快照一起发送给负责收集全局快照的**发起进程（initiator process）**。
*   **计算在途消息（信道状态）**：发起进程通过评估 $transit(LS_i, LS_j)$ 来计算信道 $C_{ij}$ 的状态，计算方式如下：
    *   $SC_{ij} = $ 进程 $p_i$ 在信道 $C_{ij}$ 上发送的白色消息集合 **减去** 进程 $p_j$ 在该信道上接收到的白色消息集合。（通过这种方式就解决了non-FIFO信道可能产生的接收进程红色而信道中还有白色消息的问题）
    *   **形式化定义**：$SC_{ij} = \{ send(m_{ij}) \mid send(m_{ij}) \in LS_i \} - \{ rec(m_{ij}) \mid rec(m_{ij}) \in LS_j \}$。

**补充说明：**
由于在非 FIFO（非先进先出）系统中，消息的到达顺序是不可预测的，我们不能像 Chandy-Lamport 算法那样简单地靠“标记”来截断消息流。

Lai-Yang 算法的巧妙之处在于采用了**集合减法**的思想：
1.  **发送方的视野**：$p_i$ 记录了所有在快照时刻之前（变红前）发出的“白色信件”。
2.  **接收方的视野**：$p_j$ 记录了所有在快照时刻之前（变红前）收到的“白色信件”。
3.  **逻辑差集**：发起者把这两份名单拿来对比，如果有一封信在 $p_i$ 的发送名单里，但不在 $p_j$ 的接收名单里，那么这封信在逻辑快照那一刻，就一定**正在信道中传输（即在途消息）**。

通过这种“对账”的方式，即使信道里的消息跑得再乱，发起者也能准确地把那些“漏掉”的在途消息找回来，拼凑成一个完整的一致性全局状态。

Mattern 算法是一种基于向量时钟（Vector Clocks）的分布式快照算法。该算法假设系统中只有一个发起者（Initiator）进程，其具体工作流程如下：

### **Mattern 算法的基本步骤**

1.  **启动与广播：** 发起者进程将其本地时钟“滴答”增加，并选择一个未来的向量时间 $s$ 作为记录全局快照的时间点。随后，它广播这个时间 $s$，并冻结自身的所有活动，直到收到所有其他进程对该广播的确认（acknowledgements）。
2.  **确认机制：** 当其他进程收到该广播时，会记录下数值 $s$，并向发起者返回一个确认消息。
3.  **触发阶段：** 在收到所有进程的确认后，发起者将其向量时钟增加到 $s$，并向所有进程广播一条“哑消息”（dummy message）。
4.  **强制更新：** 每个接收者在收到这条哑消息后，如果其本地时钟尚未达到 $s$，则会被强制将其时钟增加到某个大于或等于 $s$ 的值。
5.  **记录本地快照：** 每个进程在本地时钟从小于 $s$ 的值增加到大于或等于 $s$ 的值那一刻（即刚好在增加之前），拍摄本地快照（Local Snapshot, $LS$）并将其发送给发起者。
6.  **确定信道状态：** 信道 $C_{ij}$ 的状态被定义为：所有沿该信道发送、且时间戳小于 $s$ 的消息，并且这些消息是在接收进程 $p_j$ 记录完其本地快照 $LS_j$ 之后才被收到的。


### **非 FIFO 信道下的终止检测**

在非 FIFO（先入先出）信道中，由于消息可能乱序到达，需要一种终止检测方案来确保没有“白色消息”（即在快照时间点 $s$ 之前发送的消息）仍在传输途中。

**具体方法如下：**

*   **维护计数器：** 每个进程 $i$ 维护一个计数器 $cntr_i$。该计数器用于记录在拍摄快照之前，该进程发送的白色消息数量与收到的白色消息数量之间的差值。
*   **报告与转发：** 进程将此计数器的值随其本地快照一起报告给发起者进程。在此之后，该进程若收到任何白色消息，都会将其转发给发起者。
*   **终止条件：** 当发起者收到的转发白色消息的总数量等于所有进程报告的计数器之和（即 $\sum_i cntr_i$）时，快照收集过程正式终止。

**补充说明：**
所谓“白色消息”是指那些在发送者逻辑时钟达到 $s$ 之前发出的消息。在非 FIFO 环境下，这些消息可能在快照拍摄后很久才到达，因此需要通过计数器确保所有发出的白色消息都已被接收并记录在信道状态中，从而保证全局快照的一致性。

针对你提供的 Mattern 算法的“第二种方法”（Second method），这同样是解决**在非 FIFO 环境下如何知道信道快照收集何时结束**的问题。

以下是该 PPT 内容的中文还原及补充说明：

### **Mattern 算法：第二种方法 (Second Method)**

这是另一种用于检测快照终止的方案，与第一种依赖“全局计数器之和”不同，这种方法更侧重于**点对点**的感知：

*   **红色消息捎带计数：** 每个进程在拍摄本地快照后（变为红色）发送的每条**红色消息**中，都会捎带一个数值。这个数值表示：在拍摄快照之前，该进程在**该特定信道**上总共发送了多少条**白色消息**。
*   **接收端计数：** 每个进程都会为自己所有的入站信道维护一个计数器，专门统计在每个信道上已经收到了多少条白色消息。
*   **局部终止检测：** 当一个进程在某个入站信道上收到的白色消息总数，**等于**该信道上收到的红色消息所捎带的那个数值时，它就可以确定该特定信道的快照记录已经完成（即所有该收的白色消息都已收到）。


### **进一步的补充与对比（帮助理解）**

为了让你更清楚为什么有这个方法，以及它和之前的区别，可以参考以下几点：

#### **1. 它如何解决非 FIFO 带来的困扰？**
在非 FIFO 信道中，发送方先发的白色消息 $W$ 可能会比后发的红色消息 $R$ 晚到。
*   **如果没有这个方法：** 接收方收到红色消息 $R$ 后，它不知道后面是否还有“迷路”的白色消息 $W$。
*   **有了这个方法：** 红色消息 $R$ 变成了一个“通知单”。比如 $R$ 告诉接收方：“我在记录快照前一共给你发了 10 条白色消息。” 即使 $R$ 跑得快先到了，接收方数了数手里只有 9 条白消息，它就知道：“哦，还有 1 条在路上，我得继续等，直到那条到齐了，这个信道的快照才算收完。”

#### **2. 与“第一种方法”的区别**
*   **第一种方法（全局汇总）：** 每个进程把自己的差值报告给**发起者**，由发起者统一做减法，看最后是不是等于 0。这是一种**集中式**的检测。
*   **第二种方法（局部验证）：** 每个接收进程自己就能根据收到的红色消息判断某个信道是否已经“收全了”。这是一种更具**分布式**色彩的检测方式。

#### mattern相对于laiyang的改进之处
laiyang虽然通过染色机制让它可以应用在non-fifo信道中，但是依然存在不完备性。即没有内部机制去解决终止检测的问题。具体地说，虽然laiyang对进程i,j的状态做减法可以得知信道中存在在途的信息，但是它不知道什么时候结束，即不知道在途信息什么时候送达（因为laiyang没有强制转发机制）。

还有个就是目标值是动态地上报给发起者进程的，即使知道了进程A和B的之间发送-接收的差值也无法确定准确的差值是多少的，因为可能还存在进程C没有上报，而C和B之间可能也发了信息

mattern的第一种方法，它会强制所有进程上报$cntr_i$，这样发起者就知道整个系统还有多少白色消息没到达，当cntr清零，发起者就知道快照结束了；第二种方法呢，则是把检测信道结束的状态下放给了接收者，当接收者确认白色信息的数目对了，这个信道的快照就结束了。


这两张 PPT 讨论的是在**支持因果交付（Causal Delivery）**的分布式系统中，如何进行全局快照（Global Snapshot）记录。

在这种特定的系统环境下，快照算法可以利用底层的因果序属性进行简化。PPT 提到了两个著名的算法：**Acharya-Badrinath 算法**和 **Alagar-Venkatesan 算法**。

以下是对 PPT 内容的完整还原、详细解释以及额外的知识补充。

---


### 因果交付系统中的快照 (Snapshots in a causal delivery system)

*   **因果消息交付属性 (CO)**：提供了内置的消息同步机制，用于控制消息和计算消息。
*   **两种全局快照记录算法**：即 **Acharya-Badrinath** 算法和 **Alagar-Venkatesan** 算法。它们都假设底层系统支持因果消息交付。
*   在这两个算法中，**进程状态（Process State）的记录方式是相同的**，步骤如下：
    1.  一个**发起者进程（Initiator process）**向包括它自己在内的所有进程广播一个令牌（token）。
    2.  记进程 $p_i$ 接收到的令牌副本为 $token_i$。
    3.  进程 $p_i$ 在接收到 $token_i$ 时，记录其**本地快照 $LS_i$**，并将记录好的快照发送给发起者。
    4.  当发起者收到每个进程记录的快照时，算法**终止**。

#### 正确性证明 (Correctness)

对于任意两个进程 $p_i$ 和 $p_j$，满足以下属性（一致性状态的核心条件）：
$$send(m_{ij}) \notin LS_i \Rightarrow rec(m_{ij}) \notin LS_j$$
*（解释：如果消息 $m_{ij}$ 的发送动作没有被记录在 $p_i$ 的快照里，那么该消息的接收动作也绝不会出现在 $p_j$ 的快照里。）*

**证明逻辑如下：**
这是由于底层系统的**因果排序属性**（Causal Ordering Property）决定的：
*   假设有一条消息 $m_{ij}$，满足 $rec(token_i) \longrightarrow send(m_{ij})$（即 $p_i$ 在记录快照后才发送消息）。
*   由于令牌是广播的，那么存在因果链：$send(token_j) \longrightarrow send(m_{ij})$。
*   底层因果排序属性确保：$rec(token_j)$（即进程 $p_j$ 记录 $LS_j$ 的时刻）必然发生在 $rec(m_{ij})$ **之前**。
*   因此，发送动作未记录在 $LS_i$ 中的消息 $m_{ij}$，其接收动作也不会被记录在 $LS_j$ 中。

*   **注意**：这两个算法在**通道状态**的记录方法上有所不同，将在后续讨论。


> 什么是因果排序属性 (CO)？
> 这是分布式系统中的一个强约束。如果一个进程发送了 $m_1$ 接着发送了 $m_2$，或者一个进程收到 $m_1$ 后触发了 $m_2$ 的发送，那么系统必须保证所有目的地进程都在收到 $m_2$ 之前收到 $m_1$。

这两张 PPT 详细介绍了在支持因果交付（Causal Delivery）的系统中，**Acharya-Badrinath 算法**是如何记录**通道状态（Channel State）**的。

以下是对 PPT 内容的中文解释、原文还原以及相关补充知识。

---

### Acharya-Badrinath 算法中的通道状态记录

*   每个进程 $p_i$ 维护两个数组：$SENT_i[1, \dots, N]$ 和 $RECD_i[1, \dots, N]$。
    *   $SENT_i[j]$：由进程 $p_i$ 发送给进程 $p_j$ 的消息总数。
    *   $RECD_i[j]$：进程 $p_i$ 从进程 $p_j$ 接收到的消息总数。
*   **通道状态记录方式如下**：
    当进程 $p_i$ 在接收到 $token_i$ 并记录其本地快照 $LS_i$ 时，它会将 $RECD_i$ 和 $SENT_i$ 数组包含在本地状态中，然后再将快照发送给发起者（Initiator）。


当算法终止时，发起者按如下方式确定各通道的状态：

*   **从发起者到每个进程的通道状态**：为空（Empty）。
*   **从进程 $p_i$ 到进程 $p_j$ 的通道状态**：是指这样一组消息，其序列号由以下集合给定：
    $$\{RECD_j[i] + 1, \dots, SENT_i[j]\}$$
    *（解释：即 $p_i$ 发送了但 $p_j$ 尚未收到的那部分消息序列。序号从j已接收的消息下一个开始记录到i发送的最后一个消息的序号）*

**复杂度 (Complexity)**：
*   该算法需要 **$2n$ 条消息**和 **2 个时间单位**来进行快照的记录和汇聚（假设消息传递需要 1 个时间单位）。
    *   *1 个时间单位用于广播 token，$n$ 条消息。*
    *   *1 个时间单位用于各进程发回快照，$n$ 条消息。*
*   如果需要通道状态中**消息的具体内容**，则算法额外需要 $2n$ 条消息和 2 个时间单位。

---

#### 核心原理解析

1. 为什么只需要“计数”就能确定通道状态？
在普通的分布式系统（非因果序）中，为了知道通道里有哪些消息，我们需要非常复杂的机制（如 Chandy-Lamport 的 Marker）。
但在 **因果交付 (CO)** 系统中，消息是严格按序到达的。
*   如果进程 $p_i$ 说：“我给 $p_j$ 发了 10 条消息（$SENT_i[j]=10$）”。
*   进程 $p_j$ 说：“我只收到了 $p_i$ 的 7 条消息（$RECD_j[i]=7$）”。
*   由于因果序保证了消息不会乱序或跳跃，那么第 8、9、10 这三条消息**必然**还在通道中。

2. 为什么从发起者出发的通道为空？
发起者是第一个记录快照并发出 `token` 的。根据因果排序属性，发起者在拍完快照后发送的任何消息，其发送动作都在 `token` 之后。因此，这些消息到达接收者时，接收者必然已经收到了 `token` 并拍好了快照。
所以，这些消息既不在发送者的快照里，也不在接收者的快照里，它们不属于“通道状态”（即不属于“已发送但未接收”的消息）。

3. 关于“额外 $2n$ 条消息”的补充
PPT 提到，基础算法只通过 $SENT$ 和 $RECD$ 数组确定了**哪些编号**的消息在通道中（例如“第 8, 9, 10 条消息在途”）。
但发起者此时并没有这些消息的**实际内容**（Payload）。如果全局快照要求保存消息内容，发起者必须再向 $p_i$ 请求这些具体的编号消息，这就会产生额外的通信开销。


### Alagar-Venkatesan 算法中的通道状态记录

在因果交付系统中，消息被分为两类：
*   **旧消息 (old)**：如果消息的发送在因果关系上**先于**令牌（token）的发送，则称该消息为“旧”消息。
*   **新消息 (new)**：否则，该消息被称为“新”消息。

**Alagar-Venkatesan 算法记录通道状态的步骤如下：**
1.  **第一阶段**：当一个进程收到 `token` 时，它执行以下操作：
    *   记录其本地快照（Snapshot）。
    *   将所有通道的状态初始化为**空**。
    *   向发起者（Initiator）返回一条 `Done` 消息。
    *   **从此往后**，进程仅在收到“旧消息”时，才将其计入通道状态中。
2.  **第二阶段**：当发起者收到来自所有进程的 `Done` 消息后，它广播一条 `Terminate`（终止）消息。
3.  **第三阶段**：进程在收到 `Terminate` 消息后，停止快照算法（不再记录通道状态）。


#### 1. “旧消息”与“新消息”的判定原理
在支持 **CO（因果排序）** 的系统中，每个消息通常带有向量时钟（Vector Clock）。当 $p_i$ 收到 `token` 时，它会记录下当前的向量时钟 $V_{snapshot}$。
*   如果收到的消息 $m$ 携带的时钟 $V_m < V_{snapshot}$，则它是“旧消息”。
*   在 Alagar-Venkatesan 算法中，通道状态就是：**在拍完快照后收到的所有“旧消息”**。

#### 2. 为什么需要 `Terminate` 消息？
这是 Alagar-Venkatesan 算法与 Acharya-Badrinath 算法的最大区别：
*   **Acharya-Badrinath** 是“算”出来的。发起者收集所有 $SENT$ 和 $RECD$ 计数，然后在后台减一下就知道哪些在途。
*   **Alagar-Venkatesan** 是“等”出来的。每个进程在拍完快照后，进入一个“监听模式”，专门收集那些还没到的“旧消息”。
*   **问题是：要等到什么时候为止？** 进程不知道“旧消息”是否已经全部拿到了。因此需要发起者作为一个中心节点，确认大家都拍完快照了（收到所有 `Done`），再发一个 `Terminate` 通知大家可以停止监听了。

#### 3. 算法复杂度对比 ($2n$ vs $3n$)
*   **Acharya-Badrinath ($2n$ 消息)**：
    1. 发起者广播 Token ($n$)。
    2. 大家发回快照和计数 ($n$)。
    *总计 $2n$。*
*   **Alagar-Venkatesan ($3n$ 消息)**：
    1. 发起者广播 Token ($n$)。
    2. 大家发回 `Done` ($n$)。
    3. 发起者广播 `Terminate` ($n$)。
    *总计 $3n$。*

#### 4. 补充：为什么叫“分布式”计算通道状态？
在 **Acharya-Badrinath** 中，通道状态是在发起者那里算出来的（发起者拥有全局计数信息）。
在 **Alagar-Venkatesan** 中，每个进程在“监听模式”下自己就把发给自己的在途消息收集全了，然后每个进程各保存一部分通道状态，这被称为“分布式计算”。

#### 总结
Alagar-Venkatesan 算法利用了因果系统的属性，将“在途消息”转化为“快照后到达的旧消息”。虽然它比 Acharya-Badrinath 多了一轮消息传递（$3n$ vs $2n$），但它的逻辑更符合在线处理的直觉——实时捕获那些迟到的“旧消息”。

### 各快照算法总结对比 (Algorithms Comparison)

| 算法名称 | 特点与复杂度 |
| :--- | :--- |
| **Chandy-Lamport** | 基准算法。要求 FIFO 通道。复杂度为 $O(e)$ 条消息，$O(d)$ 时间。 |
| **Spezialetti-Kearns** | 支持并发发起者，高效的快照汇聚与分发。假设双向通道。$O(e)$ 记录，$O(rn^2)$ 汇聚分发。 |
| **Lai-Yang** | 适用于**非 FIFO** 通道。标记（Markers）搭在计算消息上。需要消息历史记录来计算通道状态。 |
| **Li et al.** | 需要较小的消息历史记录，因为通道状态是增量计算的。 |
| **Mattern** | 不需要消息历史记录。需要**终止检测（Termination detection）**来计算通道状态。 |
| **Acharya-Badrinath** | 要求因果交付支持。**集中式**计算通道状态。无需知道消息内容。需 $2n$ 消息，2 时间单位。 |
| **Alagar-Venkatesan** | 要求因果交付支持。**分布式**计算通道状态。需 $3n$ 消息，3 时间单位，消息体积小。 |

*注：$n$ = 进程数，$e$ = 通道数，$d$ = 网络直径，$r$ = 并发发起者数量。*


### 一致性全局快照的充要条件 

*   许多应用要求在执行过程中或事后（Post mortem）定期记录并分析本地进程状态。
*   进程在执行过程中保存的中间状态被称为该进程的一个**本地检查点（Local Checkpoint）**。
*   一个**一致性快照（Consistent Snapshot）**由一组并发发生、或具有同时发生潜力的本地状态组成。
*   进程**异步地**设置检查点。进程 $p_p$ 的第 $i$ 个（$i \ge 0$）检查点被赋予序列号 $i$，记作 **$C_{p,i}$**。
*   我们假设：每个进程在执行开始前有一个**初始检查点**，在执行结束后有一个**虚拟检查点**。
*   进程 $p_p$ 的**第 $i$ 个检查点区间（Checkpoint interval）**定义为：在其第 $(i-1)$ 个和第 $i$ 个检查点之间执行的所有计算（包括第 $(i-1)$ 个检查点，但不包括第 $i$ 个）。


*   **核心观点**：即使两个本地检查点之间没有因果路径（即互不达），它们也可能**不属于**同一个一致性全局快照。
*   **示例分析**（参考 Figure 4.2，虽然图中未画出，但给出了结论）：
    *   尽管检查点 $C_{1,1}$ 和 $C_{3,2}$ 都没有在对方之前发生（即它们在因果序上是并行的），但它们无法与进程 $p_2$ 上的任何检查点组合形成一个一致性的全局快照。
![alt text](image-13.png)
---


*   为了描述一致性快照的充分必要条件，Netzer 和 Xu 对 Lamport 的“因果先于（happen before）”关系进行了推广，定义了 **Z-路径（zigzag path）**。
*   两个检查点之间的 Z-路径类似于一条因果路径，但它允许路径中的**某条消息在上一条消息被接收之前就发出**。
*   在图 4.2 中，虽然从 $C_{1,1}$ 到 $C_{3,2}$ 不存在因果路径，但确实存在一条从 $C_{1,1}$ 到 $C_{3,2}$ 的 **Z-路径**。
*   这条 Z-路径意味着：在这次执行过程中，**不存在**任何包含 $C_{1,1}$ 和 $C_{3,2}$ 的一致性快照。

### Z-路径与一致性全局快照

**定义 (Definition)：**
从检查点 $C_{x,i}$ 到检查点 $C_{y,j}$ 存在一条 **Z-路径**，当且仅当存在消息序列 $m_1, m_2, \dots, m_n (n \ge 1)$ 满足以下条件：
1.  消息 $m_1$ 是由进程 $p_x$ 在 $C_{x,i}$ **之后**发送的。
2.  对于序列中的每一对相邻消息，如果 $m_k (1 \le k \le n)$ 被进程 $p_z$ 接收，那么 $m_{k+1}$ 是由 $p_z$ 在**同一个或更晚的**检查点区间内发送的（即便 $m_{k+1}$ 可能在 $m_k$ 被接收之前(或之后)就已经发出了）。
3.  消息 $m_n$ 被进程 $p_y$ 在 $C_{y,j}$ **之前**接收。

**示例 (Example)：**
在图 4.2 中，由于消息 $m_3$ 和 $m_4$ 的存在，从 $C_{1,1}$ 到 $C_{3,2}$ 存在一条 Z-路径。

---

### 核心原理解析：为什么 Z-路径如此重要？

#### 1. 它是对因果序的“增强版”
*   **因果路径 (Causal Path)** 要求：$C \to send(m_1) \to recv(m_1) \to send(m_2) \to recv(m_2) \dots$（时间上必须是一直向后的）。
*   **Z-路径 (Zigzag Path)** 允许：$C \to send(m_1) \to [ \text{某个区间} ] \leftarrow send(m_2) \to recv(m_2) \dots$
    *   在定义第 2 条中，关键在于“**同一个检查点区间**”。
    *   这意味着在同一个区间内，发送动作可以比接收动作更早发生。这种“逆流而上”的逻辑流依然会传递一种“**不兼容性**”。

#### 2. 直观解释 Z-路径的破坏力
我们可以把检查点看作“存档点”。
*   如果 $C_{x,i} \xrightarrow{Z-path} C_{y,j}$，说明这两个存档点之间存在某种逻辑冲突。
*   如果你试图同时读取这两个存档，你可能会发现：**根据 $p_y$ 的存档，它已经收到了某个东西；但根据 $p_x$ 的存档，那个东西根本还没发出来。**
*   即便中间隔了千山万水（多个进程），只要这根 Z 字型的链条连上了，一致性就被打破了。

#### 3. 重新审视图 4.2 的例子
*   $m_3$ 在 $C_{1,1}$ **之后**发出（满足条件 1）。
*   $p_2$ 接收了 $m_3$，而 $m_4$ 是在 $p_2$ 的**同一个检查点区间**（即 $C_{2,1}$ 到 $C_{2,2}$ 之间）发出的（满足条件 2）。
*   $m_4$ 在 $C_{3,2}$ **之前**被 $p_3$ 接收（满足条件 3）。
*   **结果**：链条打通，$C_{1,1}$ 和 $C_{3,2}$ 彻底绝缘，无法共存。

---

### 额外补充知识

#### 1. Z-环（Zigzag Cycle）
Netzer 和 Xu 的理论中还有一个更高级的推论：一个检查点 $C_{i,j}$ 是**不可恢复的（Unuseful）**，如果它参与了一个 **Z-环**。
*   如果存在一条从 $C_{i,j}$ 到它自己的 Z-路径，那么这个存档点永远无法参与任何一致性快照。这意味着这个存档是浪费的。

#### 2. 与 Chandy-Lamport 的区别
*   **Chandy-Lamport** 是通过发送 Marker 来**预防** Z-路径的产生。它强行让大家在收到 Marker 时拍快照，从而切断了形成 Z-路径的可能性。
*   **Netzer-Xu 理论** 是在**异步检查点**（大家各拍各的）的情况下，用来判断哪些存档可以拼凑在一起。这对于离线分析和非协同式的故障恢复（Non-coordinated Rollback Recovery）非常关键。

#### 3. 为什么叫 Zigzag？
因为在时序图上，这条逻辑路径不再是单一向前的射线，而是在进程区间内反复折返（Zigzagging），看起来就像“之”字形或闪电符号。

**总结建议**：理解这两页 PPT 的核心是定义中的第 2 点——**允许在同一个区间内“先发后收”**。正是这种权力的放宽，捕捉到了普通因果序捕捉不到的逻辑矛盾。
