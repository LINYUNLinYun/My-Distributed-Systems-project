# K8s
Kubernetes: Container Orchestration and Micro-Services（Kubernetes：容器编排与微服务）。
华盛顿大学计算机系，谷歌容器引擎工程师。

主要包含谷歌在西雅图和柯克兰的系统项目、Docker容器基础入门和kubernetes容器编排（主要）

## 容器


### 什么是容器？（第一部分：运行时）
这张幻灯片从底层架构的角度解释了容器是什么，以及它与传统虚拟机（VM）的区别。

*   **虚拟化内核系统调用接口 (Virtualize the kernel's syscall interface):**
    *   **核心区别：** 传统的虚拟机需要“全套装备”——一个 Hypervisor（管理程序）加上一套完整的 Guest OS（客户操作系统）。而容器直接与宿主机的内核对话，只是对系统调用进行了虚拟化。
    *   **优点：** 容器更轻量、启动更快，因为它不需要加载一个完整的操作系统内核。

*   **隔离性 (Isolation):** 容器如何实现“虽然共用一个内核，但互不干扰”？主要靠 Linux 内核的三大技术：
    1.  **chroots:** 限制进程只能看到特定的目录树，实现文件系统的隔离。
    2.  **namespaces (命名空间):** 隔离进程 ID、网络、挂载点等，让容器觉得自己在独占系统资源。
    3.  **cgroups (控制组):** 限制和监控容器使用的硬件资源（如 CPU、内存），防止某个容器吃光所有资源。

*   **打包 (Packaging) 的优势:**
    *   **密封包 (Hermetically sealed):** 容器像是一个密封的盒子，里面装好了所有运行所需的东西。
    *   **无外部依赖/无 DLL 地狱:** 解决了“在我机器上能跑，在你那里不行”的问题，因为依赖包都打包进去了，不会跟系统其他的库冲突。
    *   **便携性 (Portable):** 无论是开发者的笔记本、公司机房（On-prem）还是云端，运行环境完全一致。

*   **右侧配图：** 展示了一个内核（kernel）支撑着多个相互独立的“App + Libs”组合。这形象地说明了多个容器共享一个内核，但各自拥有独立的应用程序和库文件。

---

### 第二张 PPT：什么是容器？（第二部分：构建镜像）
这张幻灯片展示了如何通过一个简单的配置文件——**Dockerfile**，将代码转换成容器镜像。

*   **`cat - > Dockerfile`:** 这是一个 Linux 命令，表示创建一个名为 `Dockerfile` 的文件。
*   **Dockerfile 指令解析：**
    1.  **`FROM node:4.4`:** 指定基础镜像。这里是说：“给我一个已经安装好 Node.js 4.4 版本的环境”。（注：2016 年 4.4 还是主流版本）。
    2.  **`EXPOSE 8080`:** 声明容器内部应用监听的端口是 8080。
    3.  **`COPY server.js .`:** 将本地电脑上的 `server.js` 代码文件复制到镜像内部的当前目录下。
    4.  **`CMD node server.js`:** 告诉容器启动时要执行的命令。即：运行这个 Node.js 服务器。

---
这两张 PPT 展示了 Docker 操作中最核心的“三步走”流程：**写（Dockerfile）、建（Build）、跑（Run）**。

主讲人通过具体的命令，演示了如何把一个简单的 Node.js 程序变成一个真正运行的容器。

---

### 第一张 PPT：构建镜像 (Docker Build)

这一步是将你的代码和环境“打包”成一个静态文件的过程。

*   **`cat Dockerfile`**: 这部分我们之前解释过，是展示打包的“配方”。
*   **`docker build -t gcr.io/mohr-dev/hello-node:v1 .`**: 这是核心构建命令。
    *   **`docker build`**: 告诉 Docker 引擎“开始干活，给我造个镜像”。
    *   **`-t` (tag)**: 给镜像起个名字。
    *   **`gcr.io/mohr-dev/hello-node:v1`**: 这是镜像的全名。
        *   `gcr.io`: 目的地是 Google 容器注册表（仓库）。
        *   `mohr-dev`: 项目或用户名。
        *   `hello-node`: 镜像的名字。
        *   `:v1`: 版本号（标签）。有了它，你以后可以发布 v2, v3。
    *   **`.` (最后的那个点)**: 极其重要！它告诉 Docker：“就在当前这个文件夹里找 Dockerfile 和代码”。
*   **`[log spam]`**: 这是主讲人的幽默。当你运行 build 时，屏幕会刷刷刷地弹出几十行安装日志，他用这个词代替了那些无关紧要的输出信息。

---

### 第二张 PPT：运行容器 (Docker Run)

镜像建好了，它现在只是一个躺在硬盘里的静态文件。这一步是让它“活起来”。

*   **`docker run -d -p 8080:8080 --name hello_tutorial gcr.io/mohr-dev/hello-node:v1`**:
    *   **`docker run`**: 启动容器的命令。
    *   **`-d` (detached)**: 后台运行。意思是“跑起来后别占着我的终端窗口，自己去后台待着”。
    *   **`-p 8080:8080` (port)**: **端口映射**。这是最关键的一步。
        *   左边的 8080 是你**物理电脑**的端口。
        *   右边的 8080 是**容器内部**的端口。
        *   这句话的意思是：“如果有外部流量访问我电脑的 8080 端口，请把它转发给这个容器。”
    *   **`--name hello_tutorial`**: 给这个正在运行的实例起个绰号叫 `hello_tutorial`，方便以后关掉它（`docker stop hello_tutorial`）。
    *   **最后一段名称**: 指定使用刚才建好的那个 v1 版镜像。

---

### 总结：这两页 PPT 传达了什么？

1.  **标准化**：无论你的代码多么复杂，最后都变成一行简单的 `docker build`。
2.  **隔离与自洽**：通过 `-p` 端口映射，容器就像一个装了防盗门的独立小房间。你可以开很多个这样的容器，只要物理机的端口够用，它们之间互不干扰。
3.  **为 Kubernetes 做铺垫**：
    *   在 Docker 里，你需要手动输入这么多命令来“跑”一个容器。
    *   接下来的内容（Kubernetes）就会讲：**“如果你有 1000 个这样的镜像要跑，难道你要手敲 1000 次命令吗？”**
    *   Kubernetes 的作用就是自动化执行这些 `docker run`，并盯着它们，万一哪个死掉了，自动把它重启。

**通俗地说：** Docker 负责把“集装箱”造好并确保能用；接下来的 Kubernetes 则是负责管理码头和塔吊的“自动化调度系统”。

